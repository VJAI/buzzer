{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///buzzer.min.js","webpack:///webpack/bootstrap 31f3f6598600078a8e5f","webpack:///./src/core/Buzzer.js","webpack:///./src/util/Logger.js","webpack:///./src/core/Buzz.js","webpack:///./src/util/Cache.js","webpack:///./index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_classCallCheck","instance","Constructor","TypeError","BuzzerState","undefined","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","_Logger","_Logger2","Constructed","Ready","Done","NA","Buzzer","_context","_codecs","_muted","_volume","_gain","_contextType","AudioContext","webkitAudioContext","_state","context","LogType","Error","codecs","createGain","gain","connect","destination","keys","Audio","audioTest","mp3","canPlayType","replace","mpeg","opus","ogg","oga","wav","aac","caf","m4a","mp4","weba","webm","dolby","flac","volume","vol","parseFloat","isNaN","buzzer","Log","Warn","Info","log","message","type","console","ErrorType","AudioLoadState","BuzzState","_Cache","_Cache2","_Buzzer","_Buzzer2","Playing","Paused","Stopped","NotLoaded","Loading","Loaded","AudioUnAvailable","LoadError","Buzz","args","_id","Math","round","Date","now","random","_src","src","_formats","formats","_loop","loop","_preload","preload","_autoplay","autoplay","_subscribers","load","error","playstart","end","stop","pause","mute","event","on","_buffer","_bufferSource","_endTimer","_duration","_startedAt","_pausedAt","setup","_loadStatus","play","_fire","_check","loadBuffer","buffer","duration","bind","exists","retrieve","xhr","XMLHttpRequest","open","responseType","onLoad","decodeAudioData","response","store","onError","err","addEventListener","send","clearTimeout","offset","createBufferSource","start","currentTime","setTimeout","onEnd","disconnect","elapsed","fn","once","push","eventSubscribers","eventSubscriber","splice","subscriber","off","Cache","_cache","cache","_Buzz","_Buzz2"],"mappings":"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","file":"buzzer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Buzzer\"] = factory();\n\telse\n\t\troot[\"Buzzer\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Buzzer\"] = factory();\n\telse\n\t\troot[\"Buzzer\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.BuzzerState = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Logger = __webpack_require__(1);\n\nvar _Logger2 = _interopRequireDefault(_Logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Enum that represent the different states of the audio engine.\n * @enum {number}\n */\nvar BuzzerState = {\n  Constructed: 0,\n  Ready: 1,\n  Done: 2,\n  NA: 3\n};\n\n/**\n * Represents the audio engine.\n * @class\n */\n\nvar Buzzer = function () {\n\n  /**\n   * @constructor\n   */\n  function Buzzer() {\n    _classCallCheck(this, Buzzer);\n\n    this._context = null;\n    this._codecs = {};\n    this._muted = false;\n    this._volume = 1.0;\n    this._gain = null;\n    this._contextType = AudioContext || webkitAudioContext;\n    this._state = typeof this._contextType !== 'undefined' ? BuzzerState.Constructed : BuzzerState.NA;\n  }\n\n  /**\n   * Instantiate audio context and other important objects.\n   * Returns true if the setup is success.\n   * @param {AudioContext} context\n   * @returns {boolean}\n   */\n\n\n  _createClass(Buzzer, [{\n    key: 'setup',\n    value: function setup(context) {\n      if (this._state === BuzzerState.NA) {\n        (0, _Logger2.default)('Audio engine is not available because the current platform not supports Web Audio.', _Logger.LogType.Error);\n        return false;\n      }\n\n      if (this._state === BuzzerState.Ready) {\n        return true;\n      }\n\n      this._context = context || new this._contextType();\n      this.codecs();\n      this._gain = this._context.createGain();\n      this._gain.gain.value = this._volume;\n      this._gain.connect(this._context.destination);\n      this._state = BuzzerState.Ready;\n      return true;\n    }\n\n    /**\n     * Figure out the supported codecs and return the result as an object.\n     * @returns {object}\n     */\n\n  }, {\n    key: 'codecs',\n    value: function codecs() {\n      if (Object.keys(this._codecs).length === 0 && typeof Audio !== 'undefined') {\n        var audioTest = new Audio();\n\n        this._codecs = {\n          mp3: !!audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''),\n          mpeg: !!audioTest.canPlayType('audio/mpeg;').replace(/^no$/, ''),\n          opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n          ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n          oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n          wav: !!audioTest.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, ''),\n          aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n          caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n          m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n          mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n          weba: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n          webm: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n          dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n          flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n        };\n\n        audioTest = null;\n      }\n\n      return this._codecs;\n    }\n\n    /**\n     * Set/get the volume for the audio engine that controls global volume for all sounds.\n     * @param {number} vol\n     * @returns {number}\n     */\n\n  }, {\n    key: 'volume',\n    value: function volume(vol) {\n      var volume = parseFloat(vol);\n\n      if (isNaN(volume) || volume < 0 || volume > 1.0) {\n        return this._volume;\n      }\n\n      this._volume = volume;\n      this._gain && (this._gain.gain.value = this._volume);\n      return this._volume;\n    }\n\n    /**\n     * Mute the engine.\n     */\n\n  }, {\n    key: 'mute',\n    value: function mute() {\n      if (this._muted) {\n        return;\n      }\n\n      this._gain && (this._gain.gain.value = 0);\n      this._muted = true;\n    }\n\n    /**\n     * Unmute the engine.\n     */\n\n  }, {\n    key: 'unmute',\n    value: function unmute() {\n      if (!this._muted) {\n        return;\n      }\n\n      this._gain && (this._gain.gain.value = this._volume);\n      this._muted = false;\n    }\n\n    /**\n     * TODO\n     */\n\n  }, {\n    key: 'tearDown',\n    value: function tearDown() {\n      this._state = BuzzerState.Done;\n    }\n\n    /**\n     * Returns the created audio context.\n     * @returns {AudioContext}\n     */\n\n  }, {\n    key: 'context',\n    value: function context() {\n      return this._context;\n    }\n\n    /**\n     * Returns the master gain node.\n     * @returns {GainNode}\n     */\n\n  }, {\n    key: 'gain',\n    value: function gain() {\n      return this._gain;\n    }\n\n    /**\n     * Returns whether the engine is currently muted or not.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'muted',\n    value: function muted() {\n      return this._muted;\n    }\n\n    /**\n     * Returns the state of the engine.\n     * @returns {number}\n     */\n\n  }, {\n    key: 'state',\n    value: function state() {\n      return this._state;\n    }\n\n    /**\n     * Returns whether the engine is available or not.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'available',\n    value: function available() {\n      return this._state !== BuzzerState.NA;\n    }\n  }]);\n\n  return Buzzer;\n}();\n\nvar buzzer = new Buzzer();\n\nexports.BuzzerState = BuzzerState;\nexports.default = buzzer;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Enum that represents the different types of messages.\n * @enum {string}\n */\nvar LogType = {\n  Log: 'log',\n  Error: 'error',\n  Warn: 'warn',\n  Info: 'info'\n};\n\n/**\n * Logs different types of messages to console.\n * @param {*} message\n * @param {LogType} type\n */\nvar log = function log(message, type) {\n  return console[type || 'log'](message);\n};\n\nexports.LogType = LogType;\nexports.default = log;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.ErrorType = exports.AudioLoadState = exports.BuzzState = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Cache = __webpack_require__(3);\n\nvar _Cache2 = _interopRequireDefault(_Cache);\n\nvar _Logger = __webpack_require__(1);\n\nvar _Logger2 = _interopRequireDefault(_Logger);\n\nvar _Buzzer = __webpack_require__(0);\n\nvar _Buzzer2 = _interopRequireDefault(_Buzzer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Enum that represents the different states of a sound.\n * @enum {number}\n */\nvar BuzzState = {\n  Constructed: 0,\n  Playing: 1,\n  Paused: 2,\n  Stopped: 3,\n  NA: 4\n};\n\n/**\n * Enum that represents the different states of loading the audio.\n * @enum {number}\n */\nvar AudioLoadState = {\n  NotLoaded: 0,\n  Loading: 1,\n  Loaded: 2,\n  Error: 3\n};\n\n/**\n * Enum that represents the different errors thrown by a Buzz object.\n * @enum {number}\n */\nvar ErrorType = {\n  AudioUnAvailable: 1,\n  LoadError: 2\n};\n\n/**\n * Represents a single sound.\n * @class\n */\n\nvar Buzz = function () {\n\n  /**\n   * @param {object} args\n   * @param {string} args.src The source of the audio file.\n   * @param {string[]} args.formats The available formats for the file.\n   * @param {number} args.volume The initial volume of the sound.\n   * @param {number} args.loop Whether the sound should play repeatedly.\n   * @param {boolean} args.preload Load the sound initially itself.\n   * @param {boolean} args.autoplay Play automatically once the object is created.\n   * @param {function} args.onload Event-handler for the \"load\" event.\n   * @param {function} args.onerror Event-handler for the \"error\" event.\n   * @param {function} args.onplaystart Event-handler for the \"playstart\" event.\n   * @param {function} args.onend Event-handler for the \"end\" event.\n   * @param {function} args.onstop Event-handler for the \"stop\" event.\n   * @param {function} args.onpause Event-handler for the \"pause\" event.\n   * @constructor\n   */\n  function Buzz(args) {\n    _classCallCheck(this, Buzz);\n\n    this._id = Math.round(Date.now() * Math.random());\n    this._src = args.src;\n    this._formats = args.formats;\n    this._volume = args.volume || 1.0;\n    this._loop = args.loop || false;\n    this._preload = args.preload || false;\n    this._autoplay = args.autoplay || false;\n    this._subscribers = {\n      'load': [],\n      'error': [],\n      'playstart': [],\n      'end': [],\n      'stop': [],\n      'pause': [],\n      'mute': []\n    };\n\n    for (var event in this._subscribers) {\n      if (this._subscribers.hasOwnProperty(event) && typeof args['on' + event] === 'function') {\n        this.on(event, args['on' + event]);\n      }\n    }\n\n    this._buffer = null;\n    this._bufferSource = null;\n    this._endTimer = null;\n    this._duration = 0;\n    this._muted = false;\n    this._startedAt = 0;\n    this._pausedAt = 0;\n\n    if (_Buzzer2.default.setup(null)) {\n      this._context = _Buzzer2.default.context();\n      this._gain = this._context.createGain();\n      this._gain.connect(_Buzzer2.default.gain());\n      this._gain.gain.value = this._volume;\n\n      this._loadStatus = AudioLoadState.NotLoaded;\n      this._state = BuzzState.Constructed;\n\n      if (this._autoplay) {\n        this.play();\n        return;\n      }\n\n      if (this._preload) {\n        this.load();\n      }\n    } else {\n      this._state = BuzzState.NA;\n      this._fire('error', { type: ErrorType.AudioUnAvailable, error: 'Web Audio API is unavailable' });\n    }\n  }\n\n  /**\n   * Downloads the sound from the url, decode it into audio buffer and store it locally.\n   * Fires 'load' event on successful load and 'error' event on failure.\n   * @returns {Buzz}\n   */\n\n\n  _createClass(Buzz, [{\n    key: 'load',\n    value: function load() {\n      if (!this._check()) {\n        return this;\n      }\n\n      // If the loading is in progress or already the audio file is loaded return.\n      if (this._loadStatus === AudioLoadState.Loading || this._loadStatus === AudioLoadState.Loaded) {\n        return this;\n      }\n\n      var loadBuffer = function (buffer) {\n        this._buffer = buffer;\n        this._duration = buffer.duration;\n        this._loadStatus = AudioLoadState.Loaded;\n        this._fire('load', buffer);\n      }.bind(this);\n\n      if (_Cache2.default.exists(this._src)) {\n        loadBuffer(_Cache2.default.retrieve(this._src));\n        return this;\n      }\n\n      this._loadStatus = AudioLoadState.Loading;\n\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', this._src, true);\n      xhr.responseType = 'arraybuffer';\n\n      var onLoad = function onLoad() {\n        this._context.decodeAudioData(xhr.response, function (buffer) {\n          _Cache2.default.store(this._src, buffer);\n          loadBuffer(buffer);\n        }.bind(this), onError);\n      };\n\n      var onError = function onError(err) {\n        this._loadStatus = AudioLoadState.Error;\n        this._fire('error', { type: ErrorType.LoadError, error: err });\n      };\n\n      xhr.addEventListener('load', onLoad.bind(this));\n      xhr.addEventListener('error', onError.bind(this));\n      xhr.send();\n\n      return this;\n    }\n\n    /**\n     * Plays the sound.\n     * Fires 'playstart' event before playing and 'end' event after the sound is played.\n     * @returns {Buzz}\n     */\n\n  }, {\n    key: 'play',\n    value: function play() {\n      if (!this._check()) {\n        return this;\n      }\n\n      if (this._state === BuzzState.Playing) {\n        return this;\n      }\n\n      var play = function () {\n        if (this._endTimer) {\n          clearTimeout(this._endTimer);\n          this._endTimer = null;\n        }\n\n        var offset = this._pausedAt;\n        this._bufferSource = this._context.createBufferSource();\n        this._bufferSource.buffer = this._buffer;\n        this._bufferSource.connect(this._gain);\n        this._bufferSource.start(0, offset);\n        this._startedAt = this._context.currentTime - offset;\n        this._pausedAt = 0;\n        this._endTimer = setTimeout(onEnd, this._duration * 1000);\n        this._state = BuzzState.Playing;\n        this._fire('playstart');\n\n        return this;\n      }.bind(this);\n\n      var onEnd = function () {\n        this._startedAt = 0;\n        this._pausedAt = 0;\n        this._endTimer = null;\n        this._state = BuzzState.Stopped;\n        this._fire('end');\n      }.bind(this);\n\n      if (this._loadStatus === AudioLoadState.Loaded) {\n        return play();\n      } else {\n        this.on('load', play, true);\n        this.load();\n      }\n\n      return this;\n    }\n\n    /**\n     * Stops the sound that is playing or in paused state.\n     * @returns {Buzz}\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      if (!this._check()) {\n        return this;\n      }\n\n      // We can stop the sound either if it \"playing\" or in \"paused\" state.\n      if (this._state !== BuzzState.Playing && this._state !== BuzzState.Paused) {\n        return this;\n      }\n\n      this._bufferSource.disconnect();\n      this._bufferSource.stop(0);\n      this._bufferSource = null;\n      this._endTimer && clearTimeout(this._endTimer);\n      this._endTimer = null;\n      this._pausedAt = 0;\n      this._startedAt = 0;\n      this._state = BuzzState.Stopped;\n      this._fire('stop');\n\n      return this;\n    }\n\n    /**\n     * Pause the playing sound.\n     * @returns {Buzz}\n     */\n\n  }, {\n    key: 'pause',\n    value: function pause() {\n      if (!this._check()) {\n        return this;\n      }\n\n      // We can pause the sound only if it is \"playing\".\n      if (this._state !== BuzzState.Playing) {\n        return this;\n      }\n\n      var elapsed = this._context.currentTime - this._startedAt;\n      this._bufferSource.disconnect();\n      this._bufferSource.stop(0);\n      this._bufferSource = null;\n      this._endTimer && clearTimeout(this._endTimer);\n      this._endTimer = null;\n      this._startedAt = 0;\n      this._pausedAt = elapsed;\n      this._state = BuzzState.Paused;\n      this._fire('pause');\n\n      return this;\n    }\n\n    /**\n     * Mute the sound.\n     * @returns {Buzz}\n     */\n\n  }, {\n    key: 'mute',\n    value: function mute() {\n      if (this._muted) {\n        return this;\n      }\n\n      this._gain && (this._gain.gain.value = 0);\n      this._muted = true;\n\n      return this;\n    }\n\n    /**\n     * Unmute the sound.\n     * @returns {Buzz}\n     */\n\n  }, {\n    key: 'unmute',\n    value: function unmute() {\n      if (!this._muted) {\n        return;\n      }\n\n      this._gain && (this._gain.gain.value = this._volume);\n      this._muted = false;\n\n      return this;\n    }\n\n    /**\n     * Set/get the volume.\n     * @param vol\n     * @returns {Buzz|number}\n     */\n\n  }, {\n    key: 'volume',\n    value: function volume(vol) {\n      if (typeof vol === 'undefined') {\n        return this._volume;\n      }\n\n      var volume = parseFloat(vol);\n\n      if (isNaN(volume) || volume < 0 || volume > 1.0) {\n        return this;\n      }\n\n      this._volume = volume;\n      this._gain && (this._gain.gain.value = this._volume);\n\n      return this;\n    }\n  }, {\n    key: 'fadeOut',\n    value: function fadeOut() {\n      throw new Error('Not Implemented');\n    }\n  }, {\n    key: 'fadeIn',\n    value: function fadeIn() {\n      throw new Error('Not Implemented');\n    }\n\n    /**\n     * Returns whether sound is muted or not.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'muted',\n    value: function muted() {\n      return this._muted;\n    }\n\n    /**\n     * Returns the state of the sound.\n     * @returns {number}\n     */\n\n  }, {\n    key: 'state',\n    value: function state() {\n      return this._state;\n    }\n\n    /**\n     * Returns the duration of the sound.\n     * @returns {number}\n     */\n\n  }, {\n    key: 'duration',\n    value: function duration() {\n      return this._duration;\n    }\n\n    /**\n     * Method to subscribe to an event.\n     * @param event\n     * @param fn\n     * @param once\n     * @returns {Buzz}\n     */\n\n  }, {\n    key: 'on',\n    value: function on(event, fn, once) {\n      if (!this._subscribers.hasOwnProperty(event)) return this;\n      if (typeof fn !== 'function') return this;\n\n      this._subscribers[event].push({ fn: fn, once: once });\n\n      return this;\n    }\n\n    /**\n     * Method to un-subscribe from an event.\n     * @param event\n     * @param fn\n     * @returns {Buzz}\n     */\n\n  }, {\n    key: 'off',\n    value: function off(event, fn) {\n      if (!this._subscribers.hasOwnProperty(event)) return this;\n      if (typeof fn !== 'function') return this;\n\n      var eventSubscribers = this._subscribers[event];\n\n      for (var i = 0; i < eventSubscribers.length; i++) {\n        var eventSubscriber = eventSubscribers[i];\n        if (eventSubscriber.fn === fn) {\n          eventSubscribers.splice(i, 1);\n          break;\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * Method to subscribe to an event only once.\n     * @param event\n     * @param fn\n     * @returns {*|Buzz}\n     */\n\n  }, {\n    key: 'once',\n    value: function once(event, fn) {\n      return this.on(event, fn, true);\n    }\n\n    /**\n     * Fires an event passing the sound and other optional arguments.\n     * @param event\n     * @param args\n     * @returns {Buzz}\n     * @private\n     */\n\n  }, {\n    key: '_fire',\n    value: function _fire(event, args) {\n      var eventSubscribers = this._subscribers[event];\n\n      for (var i = 0; i < eventSubscribers.length; i++) {\n        var eventSubscriber = eventSubscribers[i];\n\n        setTimeout(function (subscriber) {\n          subscriber.fn(this, args);\n\n          if (subscriber.once) {\n            this.off(event, subscriber.fn);\n          }\n        }.bind(this, eventSubscriber), 0);\n      }\n\n      return this;\n    }\n\n    /**\n     * Logs error and returns false if audio is not available.\n     * @returns {boolean}\n     * @private\n     */\n\n  }, {\n    key: '_check',\n    value: function _check() {\n      if (this._state === BuzzState.NA) {\n        (0, _Logger2.default)('Web Audio API is unavailable', _Logger.LogType.Error);\n        return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return Buzz;\n}();\n\nexports.BuzzState = BuzzState;\nexports.AudioLoadState = AudioLoadState;\nexports.ErrorType = ErrorType;\nexports.default = Buzz;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Represents an in-memory cache store.\n */\nvar Cache = function () {\n\n  /**\n   * Initializes the in-memory cache object.\n   * @constructor\n   */\n  function Cache() {\n    _classCallCheck(this, Cache);\n\n    this._cache = {};\n  }\n\n  /**\n   * Stores the value in cache to the passed key.\n   * @param {string} key\n   * @param {*} value\n   */\n\n\n  _createClass(Cache, [{\n    key: \"store\",\n    value: function store(key, value) {\n      this._cache[key] = value;\n    }\n\n    /**\n     * Returns the stored value for the key.\n     * @param {string} key\n     * @returns {*}\n     */\n\n  }, {\n    key: \"retrieve\",\n    value: function retrieve(key) {\n      return this._cache[key];\n    }\n\n    /**\n     * Removes the stored item for the key.\n     * @param {string} key\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(key) {\n      delete this._cache[key];\n    }\n\n    /**\n     * Returns the number of items in the cache.\n     * @returns {number}\n     */\n\n  }, {\n    key: \"count\",\n    value: function count() {\n      return Object.keys(this._cache).length;\n    }\n\n    /**\n     * Returns true if the item exist in the cache.\n     * @param key\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"exists\",\n    value: function exists(key) {\n      return this._cache.hasOwnProperty(key);\n    }\n\n    /**\n     * Removes all items from cache.\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      this._cache = {};\n    }\n  }]);\n\n  return Cache;\n}();\n\nvar cache = new Cache();\nexports.default = cache;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Buzz = exports.buzzer = undefined;\n\nvar _Buzzer = __webpack_require__(0);\n\nvar _Buzzer2 = _interopRequireDefault(_Buzzer);\n\nvar _Buzz = __webpack_require__(2);\n\nvar _Buzz2 = _interopRequireDefault(_Buzz);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import 'babel-polyfill';\nexports.buzzer = _Buzzer2.default;\nexports.Buzz = _Buzz2.default;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// buzzer.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 31f3f6598600078a8e5f","import log, { LogType } from '../util/Logger';\n\n/**\n * Enum that represent the different states of the audio engine.\n * @enum {number}\n */\nconst BuzzerState = {\n  Constructed: 0,\n  Ready: 1,\n  Done: 2,\n  NA: 3\n};\n\n/**\n * Represents the audio engine.\n * @class\n */\nclass Buzzer {\n  \n  /**\n   * @constructor\n   */\n  constructor() {\n    this._context = null;\n    this._codecs = {};\n    this._muted = false;\n    this._volume = 1.0;\n    this._gain = null;\n    this._contextType = AudioContext || webkitAudioContext;\n    this._state = typeof this._contextType !== 'undefined' ? BuzzerState.Constructed : BuzzerState.NA;\n  }\n  \n  /**\n   * Instantiate audio context and other important objects.\n   * Returns true if the setup is success.\n   * @param {AudioContext} context\n   * @returns {boolean}\n   */\n  setup(context) {\n    if (this._state === BuzzerState.NA) {\n      log('Audio engine is not available because the current platform not supports Web Audio.', LogType.Error);\n      return false;\n    }\n    \n    if (this._state === BuzzerState.Ready) {\n      return true;\n    }\n    \n    this._context = context || new this._contextType();\n    this.codecs();\n    this._gain = this._context.createGain();\n    this._gain.gain.value = this._volume;\n    this._gain.connect(this._context.destination);\n    this._state = BuzzerState.Ready;\n    return true;\n  }\n  \n  /**\n   * Figure out the supported codecs and return the result as an object.\n   * @returns {object}\n   */\n  codecs() {\n    if (Object.keys(this._codecs).length === 0 && typeof Audio !== 'undefined') {\n      var audioTest = new Audio();\n      \n      this._codecs = {\n        mp3: !!audioTest.canPlayType('audio/mp3;').replace(/^no$/, ''),\n        mpeg: !!audioTest.canPlayType('audio/mpeg;').replace(/^no$/, ''),\n        opus: !!audioTest.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, ''),\n        ogg: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        oga: !!audioTest.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, ''),\n        wav: !!audioTest.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, ''),\n        aac: !!audioTest.canPlayType('audio/aac;').replace(/^no$/, ''),\n        caf: !!audioTest.canPlayType('audio/x-caf;').replace(/^no$/, ''),\n        m4a: !!(audioTest.canPlayType('audio/x-m4a;') || audioTest.canPlayType('audio/m4a;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        mp4: !!(audioTest.canPlayType('audio/x-mp4;') || audioTest.canPlayType('audio/mp4;') || audioTest.canPlayType('audio/aac;')).replace(/^no$/, ''),\n        weba: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        webm: !!audioTest.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, ''),\n        dolby: !!audioTest.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, ''),\n        flac: !!(audioTest.canPlayType('audio/x-flac;') || audioTest.canPlayType('audio/flac;')).replace(/^no$/, '')\n      };\n      \n      audioTest = null;\n    }\n    \n    return this._codecs;\n  }\n  \n  /**\n   * Set/get the volume for the audio engine that controls global volume for all sounds.\n   * @param {number} vol\n   * @returns {number}\n   */\n  volume(vol) {\n    var volume = parseFloat(vol);\n    \n    if (isNaN(volume) || volume < 0 || volume > 1.0) {\n      return this._volume;\n    }\n    \n    this._volume = volume;\n    this._gain && (this._gain.gain.value = this._volume);\n    return this._volume;\n  }\n  \n  /**\n   * Mute the engine.\n   */\n  mute() {\n    if (this._muted) {\n      return;\n    }\n    \n    this._gain && (this._gain.gain.value = 0);\n    this._muted = true;\n  }\n  \n  /**\n   * Unmute the engine.\n   */\n  unmute() {\n    if (!this._muted) {\n      return;\n    }\n    \n    this._gain && (this._gain.gain.value = this._volume);\n    this._muted = false;\n  }\n  \n  /**\n   * TODO\n   */\n  tearDown() {\n    this._state = BuzzerState.Done;\n  }\n  \n  /**\n   * Returns the created audio context.\n   * @returns {AudioContext}\n   */\n  context() {\n    return this._context;\n  }\n  \n  /**\n   * Returns the master gain node.\n   * @returns {GainNode}\n   */\n  gain() {\n    return this._gain;\n  }\n  \n  /**\n   * Returns whether the engine is currently muted or not.\n   * @returns {boolean}\n   */\n  muted() {\n    return this._muted;\n  }\n  \n  /**\n   * Returns the state of the engine.\n   * @returns {number}\n   */\n  state() {\n    return this._state;\n  }\n  \n  /**\n   * Returns whether the engine is available or not.\n   * @returns {boolean}\n   */\n  available() {\n    return this._state !== BuzzerState.NA;\n  }\n}\n\nconst buzzer = new Buzzer();\n\nexport { BuzzerState, buzzer as default };\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/Buzzer.js","/**\n * Enum that represents the different types of messages.\n * @enum {string}\n */\nconst LogType = {\n  Log: 'log',\n  Error: 'error',\n  Warn: 'warn',\n  Info: 'info'\n};\n\n/**\n * Logs different types of messages to console.\n * @param {*} message\n * @param {LogType} type\n */\nconst log = (message, type) => console[type || 'log'](message);\n\nexport { LogType, log as default };\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/Logger.js","import cache from '../util/Cache';\nimport log, { LogType } from '../util/Logger';\nimport buzzer from './Buzzer';\n\n/**\n * Enum that represents the different states of a sound.\n * @enum {number}\n */\nconst BuzzState = {\n  Constructed: 0,\n  Playing: 1,\n  Paused: 2,\n  Stopped: 3,\n  NA: 4\n};\n\n/**\n * Enum that represents the different states of loading the audio.\n * @enum {number}\n */\nconst AudioLoadState = {\n  NotLoaded: 0,\n  Loading: 1,\n  Loaded: 2,\n  Error: 3\n};\n\n/**\n * Enum that represents the different errors thrown by a Buzz object.\n * @enum {number}\n */\nconst ErrorType = {\n  AudioUnAvailable: 1,\n  LoadError: 2\n};\n\n/**\n * Represents a single sound.\n * @class\n */\nclass Buzz {\n  \n  /**\n   * @param {object} args\n   * @param {string} args.src The source of the audio file.\n   * @param {string[]} args.formats The available formats for the file.\n   * @param {number} args.volume The initial volume of the sound.\n   * @param {number} args.loop Whether the sound should play repeatedly.\n   * @param {boolean} args.preload Load the sound initially itself.\n   * @param {boolean} args.autoplay Play automatically once the object is created.\n   * @param {function} args.onload Event-handler for the \"load\" event.\n   * @param {function} args.onerror Event-handler for the \"error\" event.\n   * @param {function} args.onplaystart Event-handler for the \"playstart\" event.\n   * @param {function} args.onend Event-handler for the \"end\" event.\n   * @param {function} args.onstop Event-handler for the \"stop\" event.\n   * @param {function} args.onpause Event-handler for the \"pause\" event.\n   * @constructor\n   */\n  constructor(args) {\n    this._id = Math.round(Date.now() * Math.random());\n    this._src = args.src;\n    this._formats = args.formats;\n    this._volume = args.volume || 1.0;\n    this._loop = args.loop || false;\n    this._preload = args.preload || false;\n    this._autoplay = args.autoplay || false;\n    this._subscribers = {\n      'load': [],\n      'error': [],\n      'playstart': [],\n      'end': [],\n      'stop': [],\n      'pause': [],\n      'mute': []\n    };\n    \n    for (var event in this._subscribers) {\n      if (this._subscribers.hasOwnProperty(event) && typeof args['on' + event] === 'function') {\n        this.on(event, args['on' + event]);\n      }\n    }\n    \n    this._buffer = null;\n    this._bufferSource = null;\n    this._endTimer = null;\n    this._duration = 0;\n    this._muted = false;\n    this._startedAt = 0;\n    this._pausedAt = 0;\n    \n    if (buzzer.setup(null)) {\n      this._context = buzzer.context();\n      this._gain = this._context.createGain();\n      this._gain.connect(buzzer.gain());\n      this._gain.gain.value = this._volume;\n      \n      this._loadStatus = AudioLoadState.NotLoaded;\n      this._state = BuzzState.Constructed;\n      \n      if (this._autoplay) {\n        this.play();\n        return;\n      }\n      \n      if (this._preload) {\n        this.load();\n      }\n    } else {\n      this._state = BuzzState.NA;\n      this._fire('error', {type: ErrorType.AudioUnAvailable, error: 'Web Audio API is unavailable'});\n    }\n  }\n  \n  /**\n   * Downloads the sound from the url, decode it into audio buffer and store it locally.\n   * Fires 'load' event on successful load and 'error' event on failure.\n   * @returns {Buzz}\n   */\n  load() {\n    if (!this._check()) {\n      return this;\n    }\n    \n    // If the loading is in progress or already the audio file is loaded return.\n    if (this._loadStatus === AudioLoadState.Loading || this._loadStatus === AudioLoadState.Loaded) {\n      return this;\n    }\n    \n    var loadBuffer = function (buffer) {\n      this._buffer = buffer;\n      this._duration = buffer.duration;\n      this._loadStatus = AudioLoadState.Loaded;\n      this._fire('load', buffer);\n    }.bind(this);\n    \n    if (cache.exists(this._src)) {\n      loadBuffer(cache.retrieve(this._src));\n      return this;\n    }\n    \n    this._loadStatus = AudioLoadState.Loading;\n    \n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', this._src, true);\n    xhr.responseType = 'arraybuffer';\n    \n    var onLoad = function () {\n      this._context.decodeAudioData(xhr.response, function (buffer) {\n        cache.store(this._src, buffer);\n        loadBuffer(buffer);\n      }.bind(this), onError);\n    };\n    \n    var onError = function (err) {\n      this._loadStatus = AudioLoadState.Error;\n      this._fire('error', {type: ErrorType.LoadError, error: err});\n    };\n    \n    xhr.addEventListener('load', onLoad.bind(this));\n    xhr.addEventListener('error', onError.bind(this));\n    xhr.send();\n    \n    return this;\n  }\n  \n  /**\n   * Plays the sound.\n   * Fires 'playstart' event before playing and 'end' event after the sound is played.\n   * @returns {Buzz}\n   */\n  play() {\n    if (!this._check()) {\n      return this;\n    }\n    \n    if (this._state === BuzzState.Playing) {\n      return this;\n    }\n    \n    var play = function () {\n      if (this._endTimer) {\n        clearTimeout(this._endTimer);\n        this._endTimer = null;\n      }\n      \n      var offset = this._pausedAt;\n      this._bufferSource = this._context.createBufferSource();\n      this._bufferSource.buffer = this._buffer;\n      this._bufferSource.connect(this._gain);\n      this._bufferSource.start(0, offset);\n      this._startedAt = this._context.currentTime - offset;\n      this._pausedAt = 0;\n      this._endTimer = setTimeout(onEnd, this._duration * 1000);\n      this._state = BuzzState.Playing;\n      this._fire('playstart');\n      \n      return this;\n    }.bind(this);\n    \n    var onEnd = function () {\n      this._startedAt = 0;\n      this._pausedAt = 0;\n      this._endTimer = null;\n      this._state = BuzzState.Stopped;\n      this._fire('end');\n    }.bind(this);\n    \n    if (this._loadStatus === AudioLoadState.Loaded) {\n      return play();\n    } else {\n      this.on('load', play, true);\n      this.load();\n    }\n    \n    return this;\n  }\n  \n  /**\n   * Stops the sound that is playing or in paused state.\n   * @returns {Buzz}\n   */\n  stop() {\n    if (!this._check()) {\n      return this;\n    }\n    \n    // We can stop the sound either if it \"playing\" or in \"paused\" state.\n    if (this._state !== BuzzState.Playing && this._state !== BuzzState.Paused) {\n      return this;\n    }\n    \n    this._bufferSource.disconnect();\n    this._bufferSource.stop(0);\n    this._bufferSource = null;\n    this._endTimer && clearTimeout(this._endTimer);\n    this._endTimer = null;\n    this._pausedAt = 0;\n    this._startedAt = 0;\n    this._state = BuzzState.Stopped;\n    this._fire('stop');\n    \n    return this;\n  }\n  \n  /**\n   * Pause the playing sound.\n   * @returns {Buzz}\n   */\n  pause() {\n    if (!this._check()) {\n      return this;\n    }\n    \n    // We can pause the sound only if it is \"playing\".\n    if (this._state !== BuzzState.Playing) {\n      return this;\n    }\n    \n    var elapsed = this._context.currentTime - this._startedAt;\n    this._bufferSource.disconnect();\n    this._bufferSource.stop(0);\n    this._bufferSource = null;\n    this._endTimer && clearTimeout(this._endTimer);\n    this._endTimer = null;\n    this._startedAt = 0;\n    this._pausedAt = elapsed;\n    this._state = BuzzState.Paused;\n    this._fire('pause');\n    \n    return this;\n  }\n  \n  /**\n   * Mute the sound.\n   * @returns {Buzz}\n   */\n  mute() {\n    if (this._muted) {\n      return this;\n    }\n    \n    this._gain && (this._gain.gain.value = 0);\n    this._muted = true;\n    \n    return this;\n  }\n  \n  /**\n   * Unmute the sound.\n   * @returns {Buzz}\n   */\n  unmute() {\n    if (!this._muted) {\n      return;\n    }\n    \n    this._gain && (this._gain.gain.value = this._volume);\n    this._muted = false;\n    \n    return this;\n  }\n  \n  /**\n   * Set/get the volume.\n   * @param vol\n   * @returns {Buzz|number}\n   */\n  volume(vol) {\n    if (typeof vol === 'undefined') {\n      return this._volume;\n    }\n    \n    var volume = parseFloat(vol);\n    \n    if (isNaN(volume) || volume < 0 || volume > 1.0) {\n      return this;\n    }\n    \n    this._volume = volume;\n    this._gain && (this._gain.gain.value = this._volume);\n    \n    return this;\n  }\n  \n  fadeOut() {\n    throw new Error('Not Implemented');\n  }\n  \n  fadeIn() {\n    throw new Error('Not Implemented');\n  }\n  \n  /**\n   * Returns whether sound is muted or not.\n   * @returns {boolean}\n   */\n  muted() {\n    return this._muted;\n  }\n  \n  /**\n   * Returns the state of the sound.\n   * @returns {number}\n   */\n  state() {\n    return this._state;\n  }\n  \n  /**\n   * Returns the duration of the sound.\n   * @returns {number}\n   */\n  duration() {\n    return this._duration;\n  }\n  \n  /**\n   * Method to subscribe to an event.\n   * @param event\n   * @param fn\n   * @param once\n   * @returns {Buzz}\n   */\n  on(event, fn, once) {\n    if (!this._subscribers.hasOwnProperty(event)) return this;\n    if (typeof fn !== 'function') return this;\n    \n    this._subscribers[event].push({fn: fn, once: once});\n    \n    return this;\n  }\n  \n  /**\n   * Method to un-subscribe from an event.\n   * @param event\n   * @param fn\n   * @returns {Buzz}\n   */\n  off(event, fn) {\n    if (!this._subscribers.hasOwnProperty(event)) return this;\n    if (typeof fn !== 'function') return this;\n    \n    var eventSubscribers = this._subscribers[event];\n    \n    for (var i = 0; i < eventSubscribers.length; i++) {\n      var eventSubscriber = eventSubscribers[i];\n      if (eventSubscriber.fn === fn) {\n        eventSubscribers.splice(i, 1);\n        break;\n      }\n    }\n    \n    return this;\n  }\n  \n  /**\n   * Method to subscribe to an event only once.\n   * @param event\n   * @param fn\n   * @returns {*|Buzz}\n   */\n  once(event, fn) {\n    return this.on(event, fn, true);\n  }\n  \n  /**\n   * Fires an event passing the sound and other optional arguments.\n   * @param event\n   * @param args\n   * @returns {Buzz}\n   * @private\n   */\n  _fire(event, args) {\n    var eventSubscribers = this._subscribers[event];\n    \n    for (var i = 0; i < eventSubscribers.length; i++) {\n      var eventSubscriber = eventSubscribers[i];\n      \n      setTimeout(function (subscriber) {\n        subscriber.fn(this, args);\n        \n        if (subscriber.once) {\n          this.off(event, subscriber.fn);\n        }\n      }.bind(this, eventSubscriber), 0);\n    }\n    \n    return this;\n  }\n  \n  /**\n   * Logs error and returns false if audio is not available.\n   * @returns {boolean}\n   * @private\n   */\n  _check() {\n    if (this._state === BuzzState.NA) {\n      log('Web Audio API is unavailable', LogType.Error);\n      return false;\n    }\n    \n    return true;\n  }\n}\n\nexport { BuzzState, AudioLoadState, ErrorType, Buzz as default };\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/Buzz.js","/**\n * Represents an in-memory cache store.\n */\nclass Cache {\n  \n  /**\n   * Initializes the in-memory cache object.\n   * @constructor\n   */\n  constructor() {\n    this._cache = {};\n  }\n  \n  /**\n   * Stores the value in cache to the passed key.\n   * @param {string} key\n   * @param {*} value\n   */\n  store(key, value) {\n    this._cache[key] = value;\n  }\n  \n  /**\n   * Returns the stored value for the key.\n   * @param {string} key\n   * @returns {*}\n   */\n  retrieve(key) {\n    return this._cache[key];\n  }\n  \n  /**\n   * Removes the stored item for the key.\n   * @param {string} key\n   */\n  remove(key) {\n    delete this._cache[key];\n  }\n  \n  /**\n   * Returns the number of items in the cache.\n   * @returns {number}\n   */\n  count() {\n    return Object.keys(this._cache).length;\n  }\n  \n  /**\n   * Returns true if the item exist in the cache.\n   * @param key\n   * @returns {boolean}\n   */\n  exists(key) {\n    return this._cache.hasOwnProperty(key);\n  }\n  \n  /**\n   * Removes all items from cache.\n   */\n  flush() {\n    this._cache = {};\n  }\n}\n\nconst cache = new Cache();\nexport default cache;\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/Cache.js","// import 'babel-polyfill';\nimport buzzer from './src/core/Buzzer';\nimport Buzz from './src/core/Buzz';\n\nexport { buzzer, Buzz };\n\n\n\n// WEBPACK FOOTER //\n// ./index.js"],"sourceRoot":""}