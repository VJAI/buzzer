{"version":3,"sources":["webpack://$buzz/webpack/universalModuleDefinition","webpack://$buzz/webpack/bootstrap","webpack://$buzz/./src/Utility.js","webpack://$buzz/./src/DownloadResult.js","webpack://$buzz/./src/Engine.js","webpack://$buzz/./src/DownloadStatus.js","webpack://$buzz/./src/Emitter.js","webpack://$buzz/./src/Queue.js","webpack://$buzz/./src/Buzz.js","webpack://$buzz/./src/BufferLoader.js","webpack://$buzz/./src/MediaLoader.js","webpack://$buzz/./src/Html5AudioPool.js","webpack://$buzz/./src/Heap.js","webpack://$buzz/./src/Sound.js","webpack://$buzz/./src/WorkerTimer.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Utility","_navigator","_contextType","_formats","_userAgent","navigator","this","userAgent","AudioContext","webkitAudioContext","audio","Audio","mp3","Boolean","canPlayType","replace","mpeg","opus","ogg","oga","wav","aac","caf","m4a","mp4","weba","webm","dolby","flac","Math","round","Date","now","random","format","formats","find","isFormatSupported","source","ext","isBase64","exec","toLowerCase","sources","isSourceSupported","str","test","maxTouchPoints","msMaxTouchPoints","url","error","status","DownloadStatus","Failure","Success","ErrorType","NoAudio","LoadError","PlayError","EngineError","EngineState","NotReady","Ready","Suspending","Suspended","Resuming","Destroying","Done","EngineEvents","Add","Remove","Volume","Mute","Pause","Stop","Suspend","Resume","Error","userInputEventNames","engine","_id","utility","id","_muted","_volume","_maxNodesPerSource","_cleanUpInterval","_inactiveTime","_autoEnable","_intervalId","_isAudioAvailable","_state","_context","_gainNode","_queue","_heap","_bufferLoader","_mediaLoader","Heap","Queue","_resumeAndRemoveListeners","args","getContext","_fire","type","volume","muted","maxNodesPerSource","cleanUpInterval","autoEnable","onadd","onremove","onstop","onpause","onmute","onvolume","onsuspend","onresume","onerror","ondone","on","BufferLoader","MediaLoader","state","forEach","eventName","document","addEventListener","createGain","gain","setValueAtTime","currentTime","connect","destination","setInterval","free","urls","progressCallback","load","groupId","allocateForGroup","src","soundId","allocateForSound","unload","releaseForGroup","releaseForSound","hasFreeNodes","destroyAllocatedAudio","vol","undefined","sounds","sound","stop","add","suspend","then","run","resume","cleanUp","clearInterval","destroy","dispose","clear","emitter","remove","terminate","close","handler","once","off","idOrUrl","Sound","_gain","removeSound","idle","fire","default","Emitter","_objectsEventsHandlersMap","_hasObject","objEvents","push","_hasEvent","filter","eventSubscriber","eventSubscribers","length","setTimeout","subscriber","_eventActions","actionIdentifier","action","removeAfterRun","hasEvent","fn","keys","_run","hasAction","queued","BuzzState","Destroyed","BuzzEvents","Load","LoadProgress","UnLoad","PlayStart","PlayEnd","Seek","Rate","FadeStart","FadeEnd","FadeStop","Destroy","LoadState","NotLoaded","Loading","Loaded","AudioUnLoad","Buzz","_src","_format","_sprite","_rate","_loop","_preload","_autoplay","_stream","_duration","_compatibleSrc","_loadState","_engine","_fading","_fadeTimer","_noOfLoadCalls","_onLoadProgress","setup","_onEngineResume","isAudioAvailable","Array","isArray","sprite","rate","loop","autoplay","stream","preload","onload","onloadprogress","onunload","onplaystart","onplayend","onrate","onseek","ondestroy","play","isLoaded","getCompatibleSource","downloadResult","duration","_buffer","_onLoadFailure","indexOf","getSupportedFormat","getSupportedSource","soundOrId","_play","newSoundId","playSound","soundArgs","buffer","playEndCallback","destroyCallback","fadeEndCallback","audioErrorCallback","err","loadCallback","positions","startPos","endPos","newSound","_removePlayActions","fadeStop","_sounds","pause","isGroup","mute","unmute","to","fade","clearTimeout","seek","isPlaying","persist","abandon","evt","percentageDownloaded","playAndFire","$buzz","method","result","arguments","context","_bufferCache","_progressCallsAndCallbacks","_disposed","_load","Promise","all","map","_unload","resolve","DownloadResult","reject","decodeAudioData","arrayBuffer","data","atob","split","dataView","Uint8Array","charCodeAt","req","XMLHttpRequest","open","responseType","response","lengthComputable","loaded","total","send","heap","_audioPool","_bufferingAudios","Html5AudioPool","console","log","removeAudioObjOfUrl","audioObj","a","_cleanUp","releaseForSource","allocateForSource","onCanPlayThrough","obj","onError","canplaythrough","readyState","removeEventListener","splice","_resourceNodesMap","_heapCleaned","_createSrc","_checkMaxNodesForSrc","unallocated","_createGroup","nodes","allocated","shift","notAllocatedAudioObj","x","_destroyNode","node","audioNodes","allocatedAudioObj","soundIdOrAudio","slice","totalAllocatedLength","isIE","onend","HeapItem","HeapItemCollection","inactiveTime","_url","items","toString","values","item","soundGroupId","inactiveDurationInSeconds","lastPlayed","isPersistent","isPaused","itemsArray","_collections","col","SoundState","Playing","Paused","_audio","_bufferSourceNode","_startPos","_endPos","_currentPos","_rateSeek","_startTime","_loadCallback","_playEndCallback","_destroyCallback","_fadeEndCallback","_audioErrorCallback","_mediaElementAudioSourceNode","_endTimer","_isSprite","_lastPlayed","_persist","playbackRate","_setLoop","_onAudioError","createMediaElementSource","_onBufferEnded","_onHtml5Ended","_playHtml5","_playBuffer","_clearEndTimer","_destroyBufferNode","_onEnded","linearRampToValueAtTime","exponentialRampToValueAtTime","workerTimer","cancelScheduledValues","_getTimeVars","abs","realTime","rateElapsed","_destroyMediaSourceNode","disconnect","max","createBufferSource","startTime","start","noteGrainOn","timeout","noteGrainOff","loopStart","loopEnd","WorkerTimer","_worker","_isWorkerThreadAvailable","_timerCallbacks","_timerId","_handleMessage","Worker","blob","_getBlob","WORKER_SCRIPT","workerUrl","_createObjectURL","script","Blob","e","blobBuilderType","BlobBuilder","WebKitBlobBuilder","append","getBlob","file","URL","createObjectURL","webkitURL","callback","timerId","cb","repeat","postMessage","command","timeoutId","intervalId"],"mappings":";;;;;;;;;CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAe,MAAID,IAEnBD,EAAY,MAAIC,IARlB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,6UC/E/CC,E,WAgCJ,c,4FAAc,cAzBdC,WAAa,KAyBC,KAlBdC,aAAe,KAkBD,KAXdC,SAAW,GAWG,KALdC,WAAa,KAMc,oBAAdC,YACTC,KAAKL,WAAaI,UAClBC,KAAKF,WAAaC,UAAUE,WAIF,oBAAjBC,aACTF,KAAKJ,aAAeM,aACmB,oBAAvBC,qBAChBH,KAAKJ,aAAeO,oBAItB,IAAIC,EAAQ,IAAIC,MAEhBL,KAAKH,SAAW,CACdS,IAAKC,QAAQH,EAAMI,YAAY,cAAcC,QAAQ,OAAQ,KAC7DC,KAAMH,QAAQH,EAAMI,YAAY,eAAeC,QAAQ,OAAQ,KAC/DE,KAAMJ,QAAQH,EAAMI,YAAY,4BAA4BC,QAAQ,OAAQ,KAC5EG,IAAKL,QAAQH,EAAMI,YAAY,8BAA8BC,QAAQ,OAAQ,KAC7EI,IAAKN,QAAQH,EAAMI,YAAY,8BAA8BC,QAAQ,OAAQ,KAC7EK,IAAKP,QAAQH,EAAMI,YAAY,yBAAyBC,QAAQ,OAAQ,KACxEM,IAAKR,QAAQH,EAAMI,YAAY,cAAcC,QAAQ,OAAQ,KAC7DO,IAAKT,QAAQH,EAAMI,YAAY,gBAAgBC,QAAQ,OAAQ,KAC/DQ,IAAKV,SAASH,EAAMI,YAAY,iBAC9BJ,EAAMI,YAAY,eAClBJ,EAAMI,YAAY,eAAeC,QAAQ,OAAQ,KACnDS,IAAKX,SAASH,EAAMI,YAAY,iBAC9BJ,EAAMI,YAAY,eAClBJ,EAAMI,YAAY,eAAeC,QAAQ,OAAQ,KACnDU,KAAMZ,QAAQH,EAAMI,YAAY,+BAA+BC,QAAQ,OAAQ,KAC/EW,KAAMb,QAAQH,EAAMI,YAAY,+BAA+BC,QAAQ,OAAQ,KAC/EY,MAAOd,QAAQH,EAAMI,YAAY,4BAA4BC,QAAQ,OAAQ,KAC7Ea,KAAMf,SAASH,EAAMI,YAAY,kBAAoBJ,EAAMI,YAAY,gBAAgBC,QAAQ,OAAQ,MAGzGL,EAAQ,K,uCAQR,OAAOmB,KAAKC,MAAMC,KAAKC,MAAQH,KAAKI,Y,uCAQpC,OAAO3B,KAAKJ,e,mCAQZ,OAAO,IAAII,KAAKJ,e,yCAQhB,OAAOI,KAAKH,W,wCAQI+B,GAChB,OAAOrB,QAAQP,KAAKH,SAAS+B,M,yCAQZC,GAAS,WAC1B,OAAOA,EAAQC,MAAK,SAAAF,GAAA,OAAU,EAAKG,kBAAkBH,Q,wCAQrCI,GAChB,IAAIC,EAAMjC,KAAKkC,SAASF,GACrB,0BAA2BG,KAAKH,GAChC,gBAAiBG,KAAKH,GAGzB,SADAC,EAAO,gBAAiBE,KAAKH,KAChBhC,KAAK+B,kBAAkBE,EAAI,GAAGG,iB,yCAQ1BC,GAAS,WAC1B,OAAOA,EAAQP,MAAK,SAAAE,GAAA,OAAU,EAAKM,kBAAkBN,Q,+BAQ9CO,GACP,MAAQ,sBAAuBC,KAAKD,K,kCASpC,QAAKvC,KAAKL,YAIF,sDAAuD6C,KAAKxC,KAAKF,c,iCASzE,MAAyB,oBAAXxC,QAA2BiD,QAAS,eAAgBjD,QAC/D0C,KAAKL,YAAcK,KAAKL,WAAW8C,eAAiB,GACpDzC,KAAKL,YAAcK,KAAKL,WAAW+C,iBAAmB,K,6BAQzD,OAAOnC,QAAQP,KAAKF,YAAe,kBAAmB0C,KAAKxC,KAAKF,iB,eAIrD,IAAIJ,G,8EC9LnB,I,EAAA,O,8CAqCE,WAAYiD,EAAKhE,EAAOiE,I,4FAAO,cAzB/BD,IAAM,KAyByB,KAnB/BhE,MAAQ,KAmBuB,KAb/BiE,MAAQ,KAauB,KAP/BC,OAAS,KAQP7C,KAAK2C,IAAMA,EACX3C,KAAKrB,MAAQA,EACbqB,KAAK4C,MAAQA,GAAS,KACtB5C,KAAK6C,OAASD,EAAQE,UAAeC,QAAUD,UAAeE,U,qYCzClE,M,IACA,M,IACA,M,IACA,O,IACA,M,IACA,M,IACA,O,mDAMA,IAAMC,EAAY,CAChBC,QAAS,WACTC,UAAW,OACXC,UAAW,OACXC,YAAa,UAOTC,EAAc,CAClBC,SAAU,WACVC,MAAO,QACPC,WAAY,aACZC,UAAW,YACXC,SAAU,WACVC,WAAY,aACZC,KAAM,OACNX,QAAS,YAOLY,EAAe,CACnBC,IAAK,MACLC,OAAQ,SACRC,OAAQ,SACRC,KAAM,OACNC,MAAO,QACPC,KAAM,OACNC,QAAS,UACTC,OAAQ,SACRC,MAAO,QACPV,KAAM,QAOFW,EAAsB,CAC1B,QACA,cACA,WACA,WACA,YACA,UACA,YACA,WACA,UACA,SAmsBIC,EAAS,I,WAtkBb,c,4FAAc,cA/GdC,IAAMC,UAAQC,KA+GA,KAxGdC,QAAS,EAwGK,KAjGdC,QAAU,EAiGI,KA1FdC,mBAAqB,GA0FP,KAnFdC,iBAAmB,EAmFL,KA5EdC,cAAgB,EA4EF,KArEdC,aAAc,EAqEA,KA9DdC,YAAc,KA8DA,KAvDdC,mBAAoB,EAuDN,KAhDdC,OAAS/B,EAAYC,SAgDP,KAzCd+B,SAAW,KAyCG,KAlCdC,UAAY,KAkCE,KA3BdC,OAAS,KA2BK,KApBdC,MAAQ,KAoBM,KAbdC,cAAgB,KAaF,KANdC,aAAe,KAOb3F,KAAKyF,MAAQ,IAAIG,UAAK5F,KAAKiF,eAC3BjF,KAAKwF,OAAS,IAAIK,UAClB7F,KAAK8F,0BAA4B9F,KAAK8F,0BAA0B5G,KAAKc,M,wCAuBjE+F,GAAM,WAEV,GAAI/F,KAAKqF,SAAW/B,EAAYC,SAC9B,OAAOvD,KAST,GANAA,KAAKsF,SAAWX,UAAQqB,aAGxBhG,KAAKoF,kBAAoB7E,QAAQP,KAAKsF,WAGjCtF,KAAKoF,kBAGR,OAFApF,KAAKqF,OAAS/B,EAAYJ,QAC1BlD,KAAKiG,MAAMnC,EAAaS,MAAO,CAAE2B,KAAMjD,EAAUC,QAASN,MAAO,mCAC1D5C,KAfC,MAmCN+F,GAAQ,GAfVI,EApBQ,EAoBRA,OACAC,EArBQ,EAqBRA,MACAC,EAtBQ,EAsBRA,kBACAC,EAvBQ,EAuBRA,gBACAC,EAxBQ,EAwBRA,WACAC,EAzBQ,EAyBRA,MACAC,EA1BQ,EA0BRA,SACAC,EA3BQ,EA2BRA,OACAC,EA5BQ,EA4BRA,QACAC,EA7BQ,EA6BRA,OACAC,EA9BQ,EA8BRA,SACAC,EA/BQ,EA+BRA,UACAC,EAhCQ,EAgCRA,SACAC,EAjCQ,EAiCRA,QACAC,EAlCQ,EAkCRA,OAyCF,MArCkB,iBAAXd,GAAuBA,GAAU,GAAKA,GAAU,IAAQnG,KAAK8E,QAAUqB,GAC7D,kBAAVC,IAAwBpG,KAAK6E,OAASuB,GAChB,iBAAtBC,IAAmCrG,KAAK+E,mBAAqBsB,GACzC,iBAApBC,IAAiCtG,KAAKgF,iBAAmBsB,GAC1C,kBAAfC,IAA6BvG,KAAKkF,YAAcqB,GACtC,mBAAVC,GAAwBxG,KAAKkH,GAAGpD,EAAaC,IAAKyC,GACrC,mBAAbC,GAA2BzG,KAAKkH,GAAGpD,EAAaE,OAAQyC,GAC7C,mBAAXC,GAAyB1G,KAAKkH,GAAGpD,EAAaM,KAAMsC,GACxC,mBAAZC,GAA0B3G,KAAKkH,GAAGpD,EAAaK,MAAOwC,GAC3C,mBAAXC,GAAyB5G,KAAKkH,GAAGpD,EAAaI,KAAM0C,GACvC,mBAAbC,GAA2B7G,KAAKkH,GAAGpD,EAAaG,OAAQ4C,GAC1C,mBAAdC,GAA4B9G,KAAKkH,GAAGpD,EAAaO,QAASyC,GAC7C,mBAAbC,GAA2B/G,KAAKkH,GAAGpD,EAAaQ,OAAQyC,GAC5C,mBAAZC,GAA0BhH,KAAKkH,GAAGpD,EAAaS,MAAOyC,GAC3C,mBAAXC,GAAyBjH,KAAKkH,GAAGpD,EAAaD,KAAMoD,GAG3DjH,KAAK0F,cAAgB,IAAIyB,UAAanH,KAAKsF,UAG3CtF,KAAK2F,aAAe,IAAIyB,UAAYpH,KAAK+E,mBAAoB/E,KAAKyF,OAI9DzF,KAAKkF,aAAuC,cAAxBlF,KAAKsF,SAAS+B,OACpC7C,EAAoB8C,SAAQ,SAAAC,GAAA,OAAaC,SAASC,iBAAiBF,EAAW,EAAKzB,8BAIrF9F,KAAKuF,UAAYvF,KAAKsF,SAASoC,aAC/B1H,KAAKuF,UAAUoC,KAAKC,eAAe5H,KAAK6E,OAAS,EAAI7E,KAAK8E,QAAS9E,KAAKsF,SAASuC,aACjF7H,KAAKuF,UAAUuC,QAAQ9H,KAAKsF,SAASyC,aAErC/H,KAAKmF,YAAc7H,OAAO0K,YAAYhI,KAAKyF,MAAMwC,KAA8B,GAAxBjI,KAAKgF,iBAAwB,KAEpFhF,KAAKqF,OAAiC,cAAxBrF,KAAKsF,SAAS+B,MAAwB/D,EAAYE,MAAQF,EAAYI,UAE7E1D,O,2BASJkI,EAAMC,GACT,OAAOnI,KAAK0F,cAAc0C,KAAKF,EAAMC,K,gCAQ7BD,GACR,OAAOlI,KAAK2F,aAAayC,KAAKF,K,uCASfvF,EAAK0F,GACpB,OAAOrI,KAAK2F,aAAa2C,iBAAiB3F,EAAK0F,K,uCAUhCE,EAAKF,EAASG,GAC7B,OAAOxI,KAAK2F,aAAa8C,iBAAiBF,EAAKF,EAASG,K,6BAQnDN,GACL,OAAIA,GACFlI,KAAK0F,cAAcgD,OAAOR,GACnBlI,OAGTA,KAAK0F,cAAcgD,SAEZ1I,Q,kCAQGkI,GACV,OAAIA,GACFlI,KAAK2F,aAAa+C,OAAOR,GAClBlI,OAGTA,KAAK2F,aAAa+C,SAEX1I,Q,sCAUO2C,EAAK0F,GAAuB,IAAdJ,EAAc,wDAE1C,OADAjI,KAAK2F,aAAagD,gBAAgBhG,EAAK0F,EAASJ,GACzCjI,O,sCAUOuI,EAAKF,EAASG,GAE5B,OADAxI,KAAK2F,aAAaiD,gBAAgBL,EAAKF,EAASG,GACzCxI,O,mCASIuI,EAAKF,GAChB,OAAOrI,KAAK2F,aAAakD,aAAaN,EAAKF,K,4CASvBE,EAAKF,EAASG,GAClCxI,KAAK2F,aAAamD,sBAAsBP,EAAKF,EAASG,K,6BAStD,OAAIxI,KAAK6E,OACA7E,MAITA,KAAKuF,UAAUoC,KAAKC,eAAe,EAAG5H,KAAKsF,SAASuC,aAGpD7H,KAAK6E,QAAS,EAGd7E,KAAKiG,MAAMnC,EAAaI,KAAMlE,KAAK6E,QAE5B7E,Q,+BASP,OAAKA,KAAK6E,QAKV7E,KAAKuF,UAAUoC,KAAKC,eAAe5H,KAAK8E,QAAS9E,KAAKsF,SAASuC,aAG/D7H,KAAK6E,QAAS,EAGd7E,KAAKiG,MAAMnC,EAAaI,KAAMlE,KAAK6E,QAE5B7E,MAZEA,O,6BAoBJ+I,GAEL,YAAYC,IAARD,EACK/I,KAAK8E,QAIK,iBAARiE,GAAoBA,EAAM,GAAKA,EAAM,EACvC/I,MAITA,KAAKuF,UAAUoC,KAAKC,eAAe5H,KAAK6E,OAAS,EAAIkE,EAAK/I,KAAKsF,SAASuC,aAGxE7H,KAAK8E,QAAUiE,EAGf/I,KAAKiG,MAAMnC,EAAaG,OAAQjE,KAAK8E,SAE9B9E,Q,6BAcP,OALAA,KAAKyF,MAAMwD,SAAS3B,SAAQ,SAAA4B,GAAA,OAASA,EAAMC,UAG3CnJ,KAAKiG,MAAMnC,EAAaM,MAEjBpE,O,gCAOC,WAER,OAAIA,KAAKqF,SAAW/B,EAAYK,UAC9B3D,KAAKwF,OAAO4D,IAAI,eAAgB,WAAW,kBAAM,EAAKC,aAC/CrJ,MAILA,KAAKqF,SAAW/B,EAAYE,MACvBxD,MAITA,KAAKmJ,OAGLnJ,KAAKqF,OAAS/B,EAAYG,WAG1BzD,KAAKsF,SAAS+D,UAAUC,MAAK,WAC3B,EAAKjE,OAAS/B,EAAYI,UAC1B,EAAK8B,OAAO+D,IAAI,iBAChB,EAAKtD,MAAMnC,EAAaO,YAGnBrE,Q,+BAOA,WAEP,OAAIA,KAAKqF,SAAW/B,EAAYG,YAC9BzD,KAAKwF,OAAO4D,IAAI,gBAAiB,UAAU,kBAAM,EAAKI,YAC/CxJ,MAGLA,KAAKqF,SAAW/B,EAAYI,UACvB1D,MAGTA,KAAKqF,OAAS/B,EAAYK,SAE1B3D,KAAKsF,SAASkE,SAASF,MAAK,WAC1B,EAAKjE,OAAS/B,EAAYE,MAC1B,EAAKgC,OAAO+D,IAAI,gBAChB,EAAKtD,MAAMnC,EAAaQ,WAGnBtE,Q,kCAOG,WACV,GAAIA,KAAKqF,SAAW/B,EAAYO,MAAQ7D,KAAKqF,SAAW/B,EAAYM,WAClE,OAAO5D,KAGT,IAAMyJ,EAAU,WAEdjF,EAAoB8C,SAAQ,SAAAC,GAAA,OAAaC,SAASC,iBAAiBF,EAAW,EAAKzB,8BAGnF,EAAKX,aAAe7H,OAAOoM,cAAc,EAAKvE,aAC9C,EAAKA,YAAc,KAGnB,EAAKM,MAAMkE,UACX,EAAKlE,MAAQ,KAGT,EAAKC,gBACP,EAAKA,cAAckE,UACnB,EAAKlE,cAAgB,MAInB,EAAKC,eACP,EAAKA,aAAaiE,UAClB,EAAKjE,aAAe,MAGtB,EAAKL,SAAW,KAChB,EAAKE,OAAOqE,QACZ,EAAKrE,OAAS,KACd,EAAKH,OAAS/B,EAAYO,KAG1B,EAAKoC,MAAMnC,EAAaD,MAExBiG,UAAQD,MAAM,EAAKnF,MAIrB,GAAI1E,KAAKsF,SAAU,CACjB,GAAItF,KAAKqF,SAAW/B,EAAYG,WAG9B,OAFAzD,KAAKwF,OAAOuE,OAAO,iBACnB/J,KAAKwF,OAAO4D,IAAI,gBAAiB,WAAW,kBAAM,EAAKY,eAChDhK,KACF,GAAIA,KAAKqF,SAAW/B,EAAYK,SAGrC,OAFA3D,KAAKwF,OAAOuE,OAAO,gBACnB/J,KAAKwF,OAAO4D,IAAI,eAAgB,WAAW,kBAAM,EAAKY,eAC/ChK,KAGTA,KAAKqF,OAAS/B,EAAYM,WAC1B5D,KAAKsF,UAAYtF,KAAKsF,SAAS2E,QAAQX,MAAK,kBAAMG,YAElDzJ,KAAKqF,OAAS/B,EAAYM,WAC1B6F,IAGF,OAAOzJ,O,yBAUNuH,EAAW2C,GAAuB,IAAdC,EAAc,wDAEnC,OADAL,UAAQ5C,GAAGlH,KAAK0E,IAAK6C,EAAW2C,EAASC,GAClCnK,O,0BASLuH,EAAW2C,GAEb,OADAJ,UAAQM,IAAIpK,KAAK0E,IAAK6C,EAAW2C,GAC1BlK,O,4BAUHqK,EAAShC,EAAStC,GACtB,GAAuB,iBAAZsE,EACT,OAAOrK,KAAKyF,MAAMyD,MAAMmB,GAG1B,IAAMnB,EAAQ,IAAIoB,UAAMvE,GAIxB,OAHA/F,KAAKyF,MAAM2D,IAAIiB,EAAShC,EAASa,GACjCA,EAAMqB,QAAQzC,QAAQ9H,KAAKuF,WAEpB2D,I,kCASGX,EAAKF,EAASG,GACxBxI,KAAKyF,MAAM+E,YAAYjC,EAAKF,EAASG,K,6BAQhCH,GACL,OAAOrI,KAAKyF,MAAMwD,OAAOZ,K,2BAUtBoC,EAAMlC,EAAKF,GAGd,OAFArI,KAAKyF,MAAMwC,KAAKwC,EAAMlC,EAAKF,GAC3BrI,KAAK2F,aAAa8D,UACXzJ,O,8BAQP,OAAOA,KAAK6E,S,8BAQZ,OAAO7E,KAAKqF,S,gCAQZ,OAAOrF,KAAKsF,W,mCAQZ,OAAOtF,KAAKuF,Y,yCAQZ,OAAOvF,KAAKoF,oB,qCAQZ,OAAOpF,KAAK0F,gB,oCAQZ,OAAO1F,KAAK2F,e,4BAUR4B,GAAoB,2BAANxB,EAAM,6BAANA,EAAM,kBAExB,OADA+D,UAAQY,KAAR,iBAAa1K,KAAK0E,IAAK6C,GAAvB,OAAqCxB,EAArC,CAA2C/F,QACpCA,O,kDAOmB,WAC1BA,KAAKwJ,SACLhF,EAAoB8C,SAAQ,SAAAC,GAAA,OAAaC,SAASC,iBAAiBF,EAAW,EAAKzB,kC,QAKpE6E,QAAVlG,E,EAAmBnB,c,EAAaQ,e,EAAcb,a,wFCjwBhC,CACrBD,QAAS,UACTD,QAAS,U,2UCFL6H,E,mIAOJC,0BAA4B,G,qCAUzBjG,EAAI2C,EAAW2C,GAAuB,IAAdC,EAAc,wDAClCnK,KAAK8K,WAAWlG,KACnB5E,KAAK6K,0BAA0BjG,GAAM,IAGvC,IAAMmG,EAAY/K,KAAK6K,0BAA0BjG,GAWjD,OATKmG,EAAUxL,eAAegI,KAC5BwD,EAAUxD,GAAa,IAGzBwD,EAAUxD,GAAWyD,KAAK,CACxBd,QAASA,EACTC,KAAMA,IAGDnK,O,0BAUL4E,EAAI2C,EAAW2C,GACjB,IAAKlK,KAAKiL,UAAUrG,EAAI2C,GACtB,OAAOvH,KAGT,IAAM+K,EAAY/K,KAAK6K,0BAA0BjG,GAUjD,OALEmG,EAAUxD,GAHP2C,EAGoBa,EAAUxD,GAAW2D,QAAO,SAAAC,GACjD,OAAOA,EAAgBjB,UAAYA,KAHd,GAOlBlK,O,2BAUJ4E,EAAI2C,GAAoB,2BAANxB,EAAM,6BAANA,EAAM,kBAC3B,IAAK/F,KAAKiL,UAAUrG,EAAI2C,GACtB,OAAOvH,KAKT,IAFA,IAAIoL,EAAmBpL,KAAK6K,0BAA0BjG,GAAI2C,GAEjD7J,EAAI,EAAGA,EAAI0N,EAAiBC,OAAQ3N,IAAK,CAChD,IAAIyN,EAAkBC,EAAiB1N,GAEvC4N,WAAW,SAAUC,GAAY,IACvBrB,EAAkBqB,EAAlBrB,QAASC,EAASoB,EAATpB,KAEjBD,eAAWnE,GAEPoE,GACFnK,KAAKoK,IAAIxF,EAAI2C,EAAW2C,IAE1BhL,KAAKc,KAAMmL,GAAkB,GAGjC,OAAOnL,O,4BAQH4E,GACJ,OAAKA,GAKD5E,KAAK8K,WAAWlG,WACX5E,KAAK6K,0BAA0BjG,GAGjC5E,OARLA,KAAK6K,0BAA4B,GAC1B7K,Q,iCAgBA4E,GACT,OAAO5E,KAAK6K,0BAA0BtL,eAAeqF,K,gCAU7CA,EAAI2C,GACZ,OAAOvH,KAAK8K,WAAWlG,IAAO5E,KAAK6K,0BAA0BjG,GAAIrF,eAAegI,O,eAIrE,IAAIqD,G,2UCrIb/E,E,mIAEJ2F,cAAgB,G,sCASZjE,EAAWkE,EAAkBC,GAA+B,IAAvBC,IAAuB,yDACzD3L,KAAK4L,SAASrE,KACjBvH,KAAKwL,cAAcjE,GAAa,IAGlCvH,KAAKwL,cAAcjE,GAAWkE,GAAoB,CAAEI,GAAIH,EAAQC,eAAgBA,K,+BAQzEpE,GACP,OAAOvH,KAAKwL,cAAcjM,eAAegI,K,gCASjCA,EAAWkE,GACnB,QAAKzL,KAAK4L,SAASrE,IAIZvH,KAAKwL,cAAcjE,GAAWhI,eAAekM,K,0BAQlDlE,EAAWkE,GAAkB,WAC/B,GAAKzL,KAAK4L,SAASrE,GAInB,QAAgC,IAArBkE,EAUXrN,OAAO0N,KAAK9L,KAAKwL,cAAcjE,IAAYD,SAAQ,SAAAoE,GAAA,OAAU,EAAKK,KAAKxE,EAAWmE,UAVlF,CACE,IAAK1L,KAAKgM,UAAUzE,EAAWkE,GAC7B,OAGFzL,KAAK+L,KAAKxE,EAAWkE,M,6BAalBlE,EAAWkE,GACXzL,KAAKwL,cAAcjM,eAAegI,KAIlCkE,SAKEzL,KAAKwL,cAAcjE,GAAWkE,UAJ5BzL,KAAKwL,cAAcjE,M,8BAW5BvH,KAAKwL,cAAgB,K,2BASlBjE,EAAWkE,GACd,IAAMQ,EAASjM,KAAKwL,cAAcjE,GAAWkE,GAC7CQ,EAAOJ,KACPI,EAAON,gBAAkB3L,KAAK+J,OAAOxC,EAAWkE,O,eAIrC5F,G,keC1Gf,O,WACA,M,IACA,M,IACA,M,IACA,M,mDAMA,IAAMqG,EAAY,CAChB1I,MAAO,QACP2I,UAAW,aAOPC,EAAa,CACjBC,KAAM,OACNC,aAAc,eACdC,OAAQ,SACRC,UAAW,YACXC,QAAS,UACTtI,MAAO,QACPC,KAAM,OACNH,OAAQ,SACRC,KAAM,OACNwI,KAAM,OACNC,KAAM,OACNC,UAAW,YACXC,QAAS,UACTC,SAAU,WACVvI,MAAO,QACPwI,QAAS,WAOLC,EAAY,CAChBC,UAAW,YACXC,QAAS,UACTC,OAAQ,SACRC,YAAa,gBAMTC,E,WAsKJ,WAAYtH,GASV,G,4FATgB,cA/JlBrB,KAAO,EA+JW,KAxJlB4I,KAAO,KAwJW,KAjJlBC,QAAU,GAiJQ,KA1IlBC,QAAU,KA0IQ,KAnIlB1I,QAAU,EAmIQ,KA5HlB2I,MAAQ,EA4HU,KArHlB5I,QAAS,EAqHS,KA9GlB6I,OAAQ,EA8GU,KAvGlBC,UAAW,EAuGO,KAhGlBC,WAAY,EAgGM,KAzFlBC,SAAU,EAyFQ,KAlFlBC,UAAY,EAkFM,KA3ElBC,eAAiB,KA2EC,KApElBC,WAAahB,EAAUC,UAoEL,KA7DlB5H,OAAS6G,EAAU1I,MA6DD,KAtDlBgC,OAAS,KAsDS,KA/ClByI,QAAU,KA+CQ,KAxClBC,SAAU,EAwCQ,KAjClBC,WAAa,KAiCK,KA/BlBC,eAAiB,EAgCfpO,KAAKqO,gBAAkBrO,KAAKqO,gBAAgBnP,KAAKc,MAGjDA,KAAKiO,QAAUxJ,UACfzE,KAAKiO,QAAQK,QACbtO,KAAKiO,QAAQ/G,GAAGpD,eAAaQ,OAAQtE,KAAKuO,gBAAkBvO,KAAKuO,gBAAgBrP,KAAKc,QAGjFA,KAAKiO,QAAQO,mBAEhB,OADAxO,KAAKiG,MAAMmG,EAAW7H,MAAO,KAAM,CAAE2B,KAAMjD,YAAUC,QAASN,MAAO,8BAC9D5C,KAGT,GAAoB,iBAAT+F,EACT/F,KAAKsN,KAAO,CAACvH,QACR,GAAI0I,MAAMC,QAAQ3I,IAASA,EAAKsF,OACrCrL,KAAKsN,KAAOvH,OACP,GAAoB,iBAAhB,IAAOA,EAAP,cAAOA,IAAmB,KAEjCnB,EAwBEmB,EAxBFnB,GACA2D,EAuBExC,EAvBFwC,IACA3G,EAsBEmE,EAtBFnE,OACA+M,EAqBE5I,EArBF4I,OACAxI,EAoBEJ,EApBFI,OACAyI,EAmBE7I,EAnBF6I,KACAxI,EAkBEL,EAlBFK,MACAyI,EAiBE9I,EAjBF8I,KACAC,EAgBE/I,EAhBF+I,SACAC,EAeEhJ,EAfFgJ,OACAC,EAcEjJ,EAdFiJ,QACAC,EAaElJ,EAbFkJ,OACAC,EAYEnJ,EAZFmJ,eACAC,EAWEpJ,EAXFoJ,SACAC,EAUErJ,EAVFqJ,YACAC,EASEtJ,EATFsJ,UACA3I,EAQEX,EARFW,OACAC,EAOEZ,EAPFY,QACAC,EAMEb,EANFa,OACAC,EAKEd,EALFc,SACAyI,EAIEvJ,EAJFuJ,OACAC,EAGExJ,EAHFwJ,OACAvI,EAEEjB,EAFFiB,QACAwI,EACEzJ,EADFyJ,UAIFxP,KAAK0E,IAAoB,iBAAPE,EAAkBA,EAAKD,UAAQC,KAG9B,iBAAR2D,EACTvI,KAAKsN,KAAO,CAAC/E,GACJkG,MAAMC,QAAQnG,IAAQA,EAAI8C,SACnCrL,KAAKsN,KAAO/E,GAIVkG,MAAMC,QAAQ9M,GAChB5B,KAAKuN,QAAU3L,EACY,iBAAXA,GAAuBA,IACvC5B,KAAKuN,QAAU,CAAC3L,IAIA,iBAAlB,IAAO+M,EAAP,cAAOA,MAAwB3O,KAAKwN,QAAUmB,GAC5B,iBAAXxI,GAAuBA,GAAU,GAAKA,GAAU,IAAQnG,KAAK8E,QAAUqB,GAC9D,iBAATyI,GAAqBA,GAAQ,IAAOA,GAAQ,IAAM5O,KAAKyN,MAAQmB,GACrD,kBAAVxI,IAAwBpG,KAAK6E,OAASuB,GAC7B,kBAATyI,IAAuB7O,KAAK0N,MAAQmB,GACvB,kBAAbC,IAA2B9O,KAAK4N,UAAYkB,GACjC,kBAAXC,IAAyB/O,KAAK6N,QAAUkB,GAC5B,kBAAZC,IAA0BhP,KAAK2N,SAAWqB,GAG/B,mBAAXC,GAAyBjP,KAAKkH,GAAGkF,EAAWC,KAAM4C,GAC/B,mBAAnBC,GAAiClP,KAAKkH,GAAGkF,EAAWE,aAAc4C,GACrD,mBAAbC,GAA2BnP,KAAKkH,GAAGkF,EAAWG,OAAQ4C,GACtC,mBAAhBC,GAA8BpP,KAAKkH,GAAGkF,EAAWI,UAAW4C,GAC9C,mBAAdC,GAA4BrP,KAAKkH,GAAGkF,EAAWK,QAAS4C,GAC7C,mBAAX3I,GAAyB1G,KAAKkH,GAAGkF,EAAWhI,KAAMsC,GACtC,mBAAZC,GAA0B3G,KAAKkH,GAAGkF,EAAWjI,MAAOwC,GACzC,mBAAXC,GAAyB5G,KAAKkH,GAAGkF,EAAWlI,KAAM0C,GACrC,mBAAbC,GAA2B7G,KAAKkH,GAAGkF,EAAWnI,OAAQ4C,GAC3C,mBAAXyI,GAAyBtP,KAAKkH,GAAGkF,EAAWO,KAAM2C,GACvC,mBAAXC,GAAyBvP,KAAKkH,GAAGkF,EAAWM,KAAM6C,GACtC,mBAAZvI,GAA0BhH,KAAKkH,GAAGkF,EAAW7H,MAAOyC,GACtC,mBAAdwI,GAA4BxP,KAAKkH,GAAGkF,EAAWW,QAASyC,GAIjE,IAAKxP,KAAKsN,KACR,MAAM,IAAI/I,MAAM,6CAIlBvE,KAAKwF,OAAS,IAAIK,UAEd7F,KAAK4N,UACP5N,KAAKyP,OACIzP,KAAK2N,UACd3N,KAAKoI,O,uCASJI,GAAS,WACZ,GAAIA,EAAS,CACX,IAAMU,EAAQlJ,KAAKkJ,MAAMV,GAEzB,OADAU,GAASA,EAAMd,OACRpI,KAGT,IAAKA,KAAK6N,UAAY7N,KAAK0P,YAAc1P,KAAKgO,aAAehB,EAAUE,SACrE,OAAOlN,KAGTA,KAAKgO,WAAahB,EAAUE,QAE5BlN,KAAKoO,eAAiBpO,KAAKoO,eAAiB,EAE5C,IAAM7F,EAAMvI,KAAK+N,iBAAmB/N,KAAK+N,eAAiB/N,KAAK2P,uBAqC/D,OAlCc3P,KAAK6N,QAAU7N,KAAKiO,QAAQ3F,iBAAiBC,EAAKvI,KAAK0E,KAAO1E,KAAKiO,QAAQ7F,KAAKG,EAAKvI,KAAKqO,kBAClG/E,MAAK,SAAAsG,GAIT,GAFA,EAAKxB,eAAiB,IAAM,EAAKA,eAAiB,EAAKA,eAAiB,GAEpE,EAAKP,SAAW,EAAKxI,SAAW6G,EAAUC,UAC5C,EAAK8B,QAAQtF,gBAAgB,EAAKoF,eAAgB,EAAKrJ,IAAK,EAAKsJ,aAAehB,EAAUI,kBAErF,GAAI,EAAK/H,SAAW6G,EAAUC,WAAa,EAAK6B,aAAehB,EAAUC,UAShF,OAAI2C,EAAe/M,SAAWC,UAAeE,SACvC,EAAK6K,QACP,EAAKC,UAAY8B,EAAejR,MAAMkR,UAEtC,EAAKC,QAAUF,EAAejR,MAC9B,EAAKmP,UAAY,EAAKgC,QAAQD,UAGhC,EAAK7B,WAAahB,EAAUG,OAC5B,EAAKlH,MAAMmG,EAAWC,KAAM,KAAMuD,QAClC,EAAKpK,OAAO+D,IAAI,oBAIlB,EAAKwG,eAAeH,EAAehN,UAG9B5C,O,4CASP,OAAOA,KAAKuN,QAAQlC,OAClBrL,KAAKsN,KAAKtN,KAAKuN,QAAQyC,QAAQrL,UAAQsL,mBAAmBjQ,KAAKuN,WAC/D5I,UAAQuL,mBAAmBlQ,KAAKsN,Q,2BAQ/B6C,GAAW,WAId,GAHwC,iBAAdA,EAGV,CACd,IAAMjH,EAAQlJ,KAAKiO,QAAQ/E,MAAMiH,GAEjC,OADAjH,GAASlJ,KAAKoQ,MAAMlH,GACblJ,KAGT,IAAMqQ,EAAa1L,UAAQC,KACzB0L,EAAY,WACV,IAAMC,EAAY,CAChB3L,GAAIyL,EACJG,OAAQ,EAAKV,QACbf,OAAQ,EAAKlB,QACbzN,MAAO,EAAKyN,QAAU,EAAKI,QAAQxF,iBAAiB,EAAKsF,eAAgB,EAAKrJ,IAAK2L,GAAc,KACjGlK,OAAQ,EAAKrB,QACb8J,KAAM,EAAKnB,MACXrH,MAAO,EAAKvB,OACZgK,KAAM,EAAKnB,MACX+C,gBAAiB,kBAAM,EAAKxK,MAAMmG,EAAWK,QAAS4D,IACtDK,gBAAiB,WAIf,EAAKzC,QAAQnF,sBAAsB,EAAKiF,eAAgBsC,EAAY,EAAK3L,KACzE,EAAKuJ,QAAQzD,YAAY,EAAKuD,eAAgB,EAAKrJ,IAAK2L,GACxD,EAAKpK,MAAMmG,EAAWW,QAASsD,GAC/BvG,UAAQD,MAAMwG,IAEhBM,gBAAiB,kBAAM,EAAK1K,MAAMmG,EAAWS,QAASwD,IACtDO,mBAAoB,SAAC1H,EAAO2H,GAC1B,EAAK5K,MAAMmG,EAAW7H,MAAO,CAAE2B,KAAMjD,YAAUE,UAAWqF,QAAS6H,EAAYzN,MAAOiO,IACtF,EAAK5C,QAAQnF,sBAAsB,EAAKiF,eAAgB,EAAKrJ,IAAK2L,GAClEnH,EAAMS,WAERmH,aAAc,WACZ,EAAK7K,MAAMmG,EAAWC,KAAMgE,KAIhC,GAAyB,iBAAdF,GAA0B,EAAK3C,SAAW,EAAKA,QAAQjO,eAAe4Q,GAAY,CAC3F,IAAMY,EAAY,EAAKvD,QAAQ2C,GAC/BI,EAAUS,SAAWD,EAAU,GAC/BR,EAAUU,OAASF,EAAU,GAG/B,IAAMG,EAAW,EAAKjD,QAAQ/E,MAAM,EAAK6E,eAAgB,EAAKrJ,IAAK6L,GACnE,EAAKH,MAAMc,IAWf,OAPKlR,KAAK0P,WAIRY,KAHAtQ,KAAKwF,OAAO4D,IAAI,aAAhB,QAAsCiH,GAAc,kBAAMC,OAC1DtQ,KAAKoI,QAKAiI,I,4BAQHzL,GAMJ,OALA5E,KAAKmR,mBAAmBvM,GACV,iBAAPA,GAAmB5E,KAAKoR,WAC/BpR,KAAKqR,QAAQzM,GAAI0C,SAAQ,SAAA4B,GAAA,OAASA,EAAMoI,WACxCtR,KAAKiG,MAAMmG,EAAWjI,MAAOS,GAEtB5E,O,2BAQJ4E,GAMH,OALA5E,KAAKmR,mBAAmBvM,GACV,iBAAPA,GAAmB5E,KAAKoR,WAC/BpR,KAAKqR,QAAQzM,GAAI0C,SAAQ,SAAA4B,GAAA,OAASA,EAAMC,UACxCnJ,KAAKiG,MAAMmG,EAAWhI,KAAMQ,GAErB5E,O,2BAQJ4E,GACH,IAAM2M,EAAwB,iBAAP3M,EAOvB,OANA2M,GAAWvR,KAAKoR,WAChBpR,KAAKqR,QAAQzM,GAAI0C,SAAQ,SAAA4B,GAAA,OAASA,EAAMsI,UACxCD,IAAYvR,KAAK6E,QAAS,GAE1B7E,KAAKiG,MAAMmG,EAAWlI,KAAMU,EAAI5E,KAAK6E,QAE9B7E,O,6BAQF4E,GACL,IAAM2M,EAAwB,iBAAP3M,EAOvB,OANA2M,GAAWvR,KAAKoR,WAChBpR,KAAKqR,QAAQzM,GAAI0C,SAAQ,SAAA4B,GAAA,OAASA,EAAMuI,YACxCF,IAAYvR,KAAK6E,QAAS,GAE1B7E,KAAKiG,MAAMmG,EAAWlI,KAAMU,EAAI5E,KAAK6E,QAE9B7E,O,6BASFmG,EAAQvB,GACb,IAAM2M,EAAwB,iBAAP3M,EAEvB,GAAsB,iBAAXuB,GAAuBA,GAAU,GAAKA,GAAU,EAKzD,OAJAoL,GAAWvR,KAAKoR,WAChBpR,KAAKqR,QAAQzM,GAAI0C,SAAQ,SAAA4B,GAAA,OAASA,EAAM/C,OAAOA,MACjC,iBAAPvB,IAAoB5E,KAAK8E,QAAUqB,GAC1CnG,KAAKiG,MAAMmG,EAAWnI,OAAQW,EAAI5E,KAAK8E,SAChC9E,KAGT,IAAKuR,EAAS,CACZ,IAAMrI,EAAQlJ,KAAKiO,QAAQ/E,MAAMtE,GACjC,OAAOsE,EAAQA,EAAM/C,SAAW,KAGlC,OAAOnG,KAAK8E,U,2BAWT4M,EAAI7B,GAA+B,WAArB3J,EAAqB,uDAAd,SAAUtB,EAAI,aAChC2M,EAAwB,iBAAP3M,EAEvB,OAAI2M,GAAWvR,KAAKkO,QACXlO,MAGTA,KAAKiG,MAAMmG,EAAWQ,UAAWhI,GAEjC5E,KAAKqR,QAAQzM,GAAI0C,SAAQ,SAAA4B,GAAA,OAASA,EAAMyI,KAAKD,EAAI7B,EAAU3J,MAEvDqL,IACFvR,KAAKkO,SAAU,EAEflO,KAAKmO,WAAa7C,YAAW,WAC3B,EAAKnF,OAAOuL,GAEZE,aAAa,EAAKzD,YAElB,EAAKA,WAAa,KAClB,EAAKD,SAAU,EACf,EAAKjI,MAAMmG,EAAWS,WACV,IAAXgD,IAGE7P,Q,+BAQA4E,GACP,IAAM2M,EAAwB,iBAAP3M,EAEvB,OAAI2M,IAAYvR,KAAKkO,QACZlO,MAGTA,KAAKqR,QAAQzM,GAAI0C,SAAQ,SAAA4B,GAAA,OAASA,EAAMkI,cAEpCG,IACEvR,KAAKmO,aACPyD,aAAa5R,KAAKmO,YAClBnO,KAAKmO,WAAa,MAGpBnO,KAAKkO,SAAU,GAGjBlO,KAAKiG,MAAMmG,EAAWU,SAAUlI,GAEzB5E,Q,2BASJ4O,EAAMhK,GACT,GAAoB,iBAATgK,GAAqBA,GAAQ,IAAOA,GAAQ,EAIrD,OAHA5O,KAAKqR,QAAQzM,GAAI0C,SAAQ,SAAA4B,GAAA,OAASA,EAAM0F,KAAKA,MAC/B,iBAAPhK,IAAoB5E,KAAKyN,MAAQmB,GACxC5O,KAAKiG,MAAMmG,EAAWO,KAAM/H,EAAI5E,KAAKyN,OAC9BzN,KAGT,GAAkB,iBAAP4E,EAAiB,CAC1B,IAAMsE,EAAQlJ,KAAKiO,QAAQ/E,MAAMtE,GACjC,OAAOsE,EAAQA,EAAM0F,OAAS,KAGhC,OAAO5O,KAAKyN,Q,2BAST7I,EAAIiN,GAAM,WACb,IAAKjN,EACH,OAAO5E,KAGT,IAAMkJ,EAAQlJ,KAAKkJ,MAAMtE,GAEzB,OAAKsE,EAIe,iBAAT2I,EAGJ7R,KAAK0P,YAMVxG,EAAM2I,KAAKA,GACX7R,KAAKiG,MAAMmG,EAAWM,KAAM9H,EAAIiN,GACzB7R,OAPLA,KAAKwF,OAAO4D,IAAI,aAAhB,QAAsCxE,GAAM,kBAAM,EAAKiN,KAAKjN,EAAIiN,MAChE7R,KAAKoI,OACEpI,MAQJkJ,EAAM2I,OAjBJ7R,O,2BA0BN6O,EAAMjK,GACT,GAAoB,kBAATiK,EAGT,OAFA7O,KAAKqR,QAAQzM,GAAI0C,SAAQ,SAAA4B,GAAA,OAASA,EAAM2F,KAAKA,MAC/B,iBAAPjK,IAAoB5E,KAAK0N,MAAQmB,GACjC7O,KAGT,GAAkB,iBAAP4E,EAAiB,CAC1B,IAAMsE,EAAQlJ,KAAKiO,QAAQ/E,MAAMtE,GACjC,OAAOsE,EAAQA,EAAM2F,OAAS,KAGhC,OAAO7O,KAAK0N,Q,8BAQN9I,GACN,IAAMsE,EAAQlJ,KAAKiO,QAAQ/E,MAAMtE,GACjC,OAAOsE,EAAQA,EAAM4I,YAAc,O,4BAQ/BlN,GACJ,GAAkB,iBAAPA,EAAiB,CAC1B,IAAMsE,EAAQlJ,KAAKiO,QAAQ/E,MAAMtE,GACjC,OAAOsE,EAAQA,EAAM9C,QAAU,KAGjC,OAAOpG,KAAK6E,S,4BAQRD,GACJ,GAAkB,iBAAPA,EAAiB,CAC1B,IAAMsE,EAAQlJ,KAAKiO,QAAQ/E,MAAMtE,GACjC,OAAOsE,EAAQA,EAAM7B,QAAU,KAGjC,OAAOrH,KAAKqF,S,+BAQLT,GACP,GAAkB,iBAAPA,EAAiB,CAC1B,IAAMsE,EAAQlJ,KAAKiO,QAAQ/E,MAAMtE,GACjC,OAAOsE,EAAQA,EAAM2G,WAAa,KAGpC,OAAO7P,KAAK8N,Y,+BAcZ,OANA9N,KAAKwF,OAAOuE,OAAO,cACnB/J,KAAK6N,SAAW7N,KAAKiO,QAAQtF,gBAAgB3I,KAAK+N,eAAgB/N,KAAK0E,KAAK,GAC5E1E,KAAK8P,QAAU,KACf9P,KAAK6N,UAAY7N,KAAK8N,UAAY,GAClC9N,KAAKgO,WAAahO,KAAK6N,QAAUb,EAAUI,YAAcJ,EAAUC,UACnEjN,KAAKoO,eAAiB,EACfpO,O,8BAODwI,GACN,GAAIA,EAAJ,CACE,IAAMU,EAAQlJ,KAAKkJ,MAAMV,GACzBU,GAASA,EAAMS,eAIb3J,KAAKqF,SAAW6G,EAAUC,YAI9BnM,KAAKmJ,OACLnJ,KAAKwF,OAAOqE,QACZ7J,KAAKiO,QAAQ7D,IAAItG,eAAaQ,OAAQtE,KAAKuO,iBAC3CvO,KAAKiO,QAAQhG,MAAK,EAAOjI,KAAK+N,eAAgB/N,KAAK0E,KACnD1E,KAAKiO,QAAQtF,gBAAgB3I,KAAK+N,eAAgB/N,KAAK0E,KAEvD1E,KAAK8P,QAAU,KACf9P,KAAKwF,OAAS,KACdxF,KAAKiO,QAAU,KACfjO,KAAKqF,OAAS6G,EAAUC,UAExBnM,KAAKiG,MAAMmG,EAAWW,SAEtBjD,UAAQD,MAAM7J,KAAK0E,Q,8BAOb8D,GACN,IAAMU,EAAQlJ,KAAKkJ,MAAMV,GACzBU,GAASA,EAAM6I,Y,8BAOTvJ,GACN,IAAMU,EAAQlJ,KAAKkJ,MAAMV,GACzBU,GAASA,EAAM8I,Y,yBAWdzK,EAAW2C,GAA2B,IAAlBC,EAAkB,wDAAJvF,EAAI,aAEvC,OADAkF,UAAQ5C,GAAGtC,GAAM5E,KAAK0E,IAAK6C,EAAW2C,EAASC,GACxCnK,O,0BAULuH,EAAW2C,EAAStF,GAEtB,OADAkF,UAAQM,IAAIxF,GAAM5E,KAAK0E,IAAK6C,EAAW2C,GAChClK,O,2BAQP,OAAOA,KAAK0E,M,kCAQZ,OAAO1E,KAAKgO,a,iCAQZ,OAAOhO,KAAK6N,QAAU7N,KAAKiO,QAAQpF,aAAa7I,KAAK+N,eAAgB/N,KAAK0E,KAAO1E,KAAKgO,aAAehB,EAAUG,S,4BAQ3GvI,GACJ,OAAO5E,KAAKiO,QAAQ/E,MAAMtE,K,4BAQtBA,GACJ,OAAOrE,QAAQP,KAAKkJ,MAAMtE,M,qCAQbhC,GAEW,IAAxB5C,KAAKoO,gBAAwBpO,KAAKwF,OAAOuE,OAAO,cAGhD/J,KAAKgO,WAAahB,EAAUC,UAG5BjN,KAAKiG,MAAMmG,EAAW7H,MAAO,KAAM,CAAE2B,KAAMjD,YAAUE,UAAWP,MAAOA,M,sCAQzDqP,GACdjS,KAAKiG,MAAMmG,EAAWE,aAAc,KAAM2F,EAAIC,wB,wCAQ9ClS,KAAKwF,OAAO+D,IAAI,yB,4BAQZL,GAAO,WACX,GAAIlJ,KAAKiO,QAAQ5G,UAAY/D,cAAYM,YAAc5D,KAAKiO,QAAQ5G,UAAY/D,cAAYO,KAK5F,GAAI7D,KAAKiO,QAAQ5G,UAAY/D,cAAYJ,QAAzC,CAKA,IAAMiP,EAAc,WAClBjJ,EAAMuG,OACN,EAAKxJ,MAAMmG,EAAWI,UAAWtD,EAAMtE,OAGzC,GAAI,CAACtB,cAAYG,WAAYH,cAAYI,UAAWJ,cAAYK,UAAUqM,QAAQhQ,KAAKiO,QAAQ5G,UAAY,EAGzG,OAFArH,KAAKwF,OAAO4D,IAAI,sBAAhB,SAAgDF,EAAMtE,MAAQ,kBAAMuN,YACpEnS,KAAKiO,QAAQ5G,UAAY/D,cAAYK,UAAY3D,KAAKiO,QAAQzE,UAIhE2I,SAfEnS,KAAKiG,MAAMmG,EAAW7H,MAAO,KAAM,CAAE2B,KAAMjD,YAAUC,QAASN,MAAO,mCALrE5C,KAAKiG,MAAMmG,EAAW7H,MAAO,KAAM,CAAE2B,KAAMjD,YAAUG,UAAWR,MAAO,qC,yCA4BxDgC,GACjB5E,KAAKwF,OAAOuE,OAAO,aAAcnF,EAAKA,QAAQA,EAAO,MACrD5E,KAAKwF,OAAOuE,OAAO,sBAAuBnF,EAAKA,SAASA,EAAO,Q,8BASzDA,GACN,GAAkB,iBAAPA,EAAiB,CAC1B,IAAMsE,EAAQlJ,KAAKiO,QAAQ/E,MAAMtE,GACjC,OAAOsE,EAAQ,CAACA,GAAS,GAG3B,OAAOlJ,KAAKiO,QAAQhF,OAAOjJ,KAAK0E,O,4BAW5B6C,EAAW3C,GAAa,2BAANmB,EAAM,6BAANA,EAAM,kBAQ5B,OAPInB,GACFkF,UAAQY,KAAR,iBAAa9F,EAAI2C,GAAjB,OAA+BxB,EAA/B,CAAqC/F,KAAKkJ,MAAMtE,GAAK5E,QACrD8J,UAAQY,KAAR,iBAAa1K,KAAK0E,IAAK6C,GAAvB,OAAqCxB,EAArC,CAA2C/F,KAAKkJ,MAAMtE,GAAK5E,SAE3D8J,UAAQY,KAAR,iBAAa1K,KAAK0E,IAAK6C,GAAvB,OAAqCxB,EAArC,CAA2C/F,QAGtCA,S,KAILoS,EAAQ,SAAArM,GAAA,OAAQ,IAAIsH,EAAKtH,IAC/B,CACE,QACA,OACA,YACA,SACA,cACA,OACA,SACA,SACA,OACA,UACA,SACA,YACA,QACA,QACA,UACA,aACA,mBACA,eACA,cACA,KACA,OACAuB,SAAQ,SAAA+K,GACRD,EAAMC,GAAU,WACd,IAAMC,EAAS7N,UAAO4N,GAAP,gBAAkBE,WACjC,OAAOD,IAAW7N,UAAS2N,EAAQE,MAIvCnV,EAAOD,QAAUkV,G,2UC/+BjB,M,IACA,M,uDAOMjL,E,WAkCJ,WAAYqL,I,4FAAS,cA3BrBlN,SAAW,KA2BU,KApBrBmN,aAAe,GAoBM,KAbrBC,2BAA6B,GAaR,KANrBC,WAAY,EAOV3S,KAAKsF,SAAWkN,E,uCASbtK,EAAMC,GAAkB,WAC3B,MAAoB,iBAATD,EACFlI,KAAK4S,MAAM1K,EAAMC,GAGnB0K,QAAQC,IAAI5K,EAAK6K,KAAI,SAAApQ,GAAA,OAAO,EAAKiQ,MAAMjQ,EAAKwF,S,6BAO9CD,GAAM,WACS,iBAATA,EAKPuG,MAAMC,QAAQxG,GAChBA,EAAKZ,SAAQ,SAAA3E,GAAA,OAAO,EAAKqQ,QAAQrQ,KAAM3C,MAIzCA,KAAKyS,aAAe,GATlBzS,KAAKgT,QAAQ9K,K,gCAgBXlI,KAAK2S,YAIT3S,KAAK0I,SACL1I,KAAKyS,aAAe,KACpBzS,KAAK0S,2BAA6B,KAClC1S,KAAKsF,SAAW,KAChBtF,KAAK2S,WAAY,K,4BAUbhQ,EAAKwF,GAAkB,WAC3B,OAAO,IAAI0K,SAAQ,SAAAI,GACjB,GAAI,EAAKR,aAAalT,eAAeoD,GACnCsQ,EAAQ,IAAIC,UAAevQ,EAAK,EAAK8P,aAAa9P,UAIpD,GAAI,EAAK+P,2BAA2BnT,eAAeoD,GACjD,EAAK+P,2BAA2B/P,GAAKqI,KAAKiI,OAD5C,CAKA,EAAKP,2BAA2B/P,GAAO,GACvC,EAAK+P,2BAA2B/P,GAAKqI,KAAKiI,GAE1C,IAAME,EAAS,SAAAtC,GACT,EAAK8B,YAIT,EAAKD,2BAA2B/P,GAAK2E,SAAQ,SAAA9I,GAAA,OAAKA,EAAE,IAAI0U,UAAevQ,EAAK,KAAMkO,cAC3E,EAAK6B,2BAA2B/P,KAGnCyQ,EAAkB,SAAAC,GAClB,EAAKV,WAIT,EAAKrN,SAAS8N,gBAAgBC,GAAa,SAAA7C,GACzC,EAAKiC,aAAa9P,GAAO6N,EACzB,EAAKkC,2BAA2B/P,GAAK2E,SAAQ,SAAA9I,GAAA,OAAKA,EAAE,IAAI0U,UAAevQ,EAAK6N,cACrE,EAAKkC,2BAA2B/P,KACtCwQ,IAGL,GAAIxO,UAAQzC,SAASS,GAArB,CAIE,IAHA,IAAM2Q,EAAOC,KAAK5Q,EAAI6Q,MAAM,KAAK,IAC3BC,EAAW,IAAIC,WAAWJ,EAAKjI,QAE5B3N,EAAI,EAAGA,EAAI4V,EAAKjI,OAAQ3N,IAC/B+V,EAAS/V,GAAK4V,EAAKK,WAAWjW,GAGhC0V,EAAgBK,EAASjD,YAR3B,CAYA,IAAMoD,EAAM,IAAIC,eAChBD,EAAIE,KAAK,MAAOnR,GAAK,GACrBiR,EAAIG,aAAe,cAEnBH,EAAInM,iBAAiB,QAAQ,kBAAM2L,EAAgBQ,EAAII,aAAW,GAE9D7L,GACFyL,EAAInM,iBAAiB,YAAY,SAACwK,GAC3BA,EAAIgC,kBACP9L,EAAiB,CAAExF,IAAKA,EAAKuP,qBAAsB,IAGrD,IAAMA,EAAuB3Q,KAAKC,MAAOyQ,EAAIiC,OAASjC,EAAIkC,MAAS,KACnEhM,EAAiB,CAAExF,IAAKA,EAAKuP,qBAAsBA,OAIvD0B,EAAInM,iBAAiB,QAAS0L,GAAQ,GACtCS,EAAIQ,c,8BASAzR,UACC3C,KAAKyS,aAAa9P,O,eAIdwE,G,uhBCpLf,M,IACA,M,uDAMMC,E,WA4BJ,WAAYf,EAAmBgO,I,4FAAM,cArBrCC,WAAa,KAqBwB,KAdrCC,iBAAmB,GAckB,KAPrC5B,WAAY,EAQV3S,KAAKsU,WAAa,IAAIE,UAAenO,EAAmBgO,G,uCAQrDnM,GAAM,WAET,OADAuM,QAAQC,SAAR,IAAmBxM,EAAnB,cAAmBA,IACC,iBAATA,EACFlI,KAAK4S,MAAM1K,GAGb2K,QAAQC,IAAI5K,EAAK6K,KAAI,SAAApQ,GAAA,OAAO,EAAKiQ,MAAMjQ,S,uCAS/BA,EAAK0F,GACpB,OAAOrI,KAAK4S,MAAMjQ,EAAK0F,K,uCAURE,EAAKF,EAASG,GAC7B,OAAOxI,KAAKsU,WAAW7L,iBAAiBF,EAAKF,EAASG,K,6BAOjDN,GAAM,WACLyM,EAAsB,SAAAhS,GAC1B,IAAMiS,EAAW,EAAKL,iBAAiBzS,MAAK,SAAA+S,GAAA,OAAKA,EAAElS,MAAQA,KAC3DiS,GAAY,EAAKE,SAASF,IAGvB1M,EAEsB,iBAATA,EAChByM,EAAoBzM,GACXuG,MAAMC,QAAQxG,IAASA,EAAKmD,QACrCnD,EAAKZ,SAAQ,SAAA3E,GAAA,OAAOgS,EAAoBhS,MAJxC3C,KAAKuU,iBAAiBjN,SAAQ,SAAAsN,GAAA,OAAY,EAAKE,SAASF,MAO1D1M,EAAKZ,SAAQ,SAAA3E,GAAA,OAAO,EAAK2R,WAAWS,iBAAiBpS,Q,sCASvCA,EAAK0F,GAAuB,WAAdJ,EAAc,wDAC1CjI,KAAKuU,iBACFrJ,QAAO,SAAA2J,GAAA,OAAKA,EAAExM,UAAYA,KAC1Bf,SAAQ,SAAAuN,GAAA,OAAK,EAAKC,SAASD,MAE9B7U,KAAKsU,WAAW3L,gBAAgBhG,EAAK0F,EAASJ,K,sCAShCM,EAAKF,EAASG,GAC5BxI,KAAKsU,WAAW1L,gBAAgBL,EAAKF,EAASG,K,mCASnCD,EAAKF,GAChB,OAAOrI,KAAKsU,WAAWzL,aAAaN,EAAKF,K,4CASrBE,EAAKF,EAASG,GAClCxI,KAAKsU,WAAWxL,sBAAsBP,EAAKF,EAASG,K,gCAOpDxI,KAAKsU,WAAW7K,Y,gCAMR,WACJzJ,KAAK2S,YAIT,U,sHAAA,CAAI3S,KAAKuU,mBAAkBjN,SAAQ,SAAAsN,GAAA,OAAY,EAAKE,SAASF,MAC7D5U,KAAKuU,iBAAmB,KACxBvU,KAAKsU,WAAW1K,UAChB5J,KAAKsU,WAAa,KAClBtU,KAAK2S,WAAY,K,4BAUbhQ,EAAK0F,GAAS,WAClB,OAAO,IAAIwK,SAAQ,SAAAI,GACjB,IAAM7S,EAAQiI,EAAU,EAAKiM,WAAWhM,iBAAiB3F,EAAK0F,GAAW,EAAKiM,WAAWU,kBAAkBrS,GAErGsS,EAAmB,WACvB,IAAI,EAAKtC,UAAT,CAIA,IAAMiC,EAAW,EAAKL,iBAAiBzS,MAAK,SAAAoT,GAAA,OAAOA,EAAI9U,QAAUA,KACjEwU,GAAY,EAAKE,SAASF,GAC1B3B,EAAQ,IAAIC,UAAevQ,EAAKvC,MAG5B+U,EAAU,SAACtE,GACf,IAAI,EAAK8B,UAAT,CAIA,IAAMiC,EAAW,EAAKL,iBAAiBzS,MAAK,SAAAoT,GAAA,OAAOA,EAAI9U,QAAUA,KACjEwU,GAAY,EAAKE,SAASF,GAC1B,EAAKN,WAAWxL,sBAAsBnG,EAAKvC,EAAOiI,GAClD4K,EAAQ,IAAIC,UAAevQ,EAAK,KAAMkO,MAcxC,GAXAzQ,EAAMqH,iBAAiB,iBAAkBwN,GACzC7U,EAAMqH,iBAAiB,QAAS0N,GAEhC,EAAKZ,iBAAiBvJ,KAAK,CACzBrI,IAAKA,EACL0F,QAASA,EACTjI,MAAOA,EACPgV,eAAgBH,EAChBrS,MAAOuS,KAGJ/U,EAAMmI,IAGT,OAFAnI,EAAMmI,IAAM5F,OACZvC,EAAMgI,OAIRhI,EAAMyH,YAAc,EAEhBzH,EAAMiV,YAAc,GACtBJ,S,+BAUGL,GACP,CAAC,iBAAkB,SAAStN,SAAQ,SAAA2K,GAAA,OAAO2C,EAASxU,MAAMkV,oBAAoBrD,EAAK2C,EAASA,OAC5F5U,KAAKuU,iBAAiBgB,OAAOvV,KAAKuU,iBAAiBvE,QAAQ4E,GAAW,O,eAI3DxN,G,yUCrOf,O,gKAMMoN,E,WAmCJ,WAAYnO,EAAmBgO,I,4FAAM,cA5BrCtP,mBAAqB,IA4BgB,KArBrCU,MAAQ,KAqB6B,KAdrC+P,kBAAoB,GAciB,KAPrCC,cAAe,EAQbzV,KAAK+E,mBAAqBsB,EAC1BrG,KAAKyF,MAAQ4O,E,oDAQG9L,GAChBvI,KAAK0V,WAAWnN,GAChBvI,KAAK2V,qBAAqBpN,GAEpB,IACFqN,EADU5V,KAAKwV,kBAAkBjN,GACjCqN,YAEExV,EAAQ,IAAIC,MAGlB,OAFAuV,EAAY5K,KAAK5K,GAEVA,I,uCASQmI,EAAKF,GACpBrI,KAAK6V,aAAatN,EAAKF,GACvBrI,KAAK2V,qBAAqBpN,GAEpB,IAAAuN,EAAQ9V,KAAKwV,kBAAkBjN,GACjCqN,EAA2BE,EAA3BF,YAAaG,EAAcD,EAAdC,UACf3V,EAAQwV,EAAYvK,OAASuK,EAAYI,QAAU,IAAI3V,MAQzD,OAPgB0V,EAAU1N,GAEd2C,KAAK,CACf5K,MAAOA,EACPoI,QAAS,OAGJpI,I,uCAUQmI,EAAKF,EAASG,GAC7BxI,KAAK6V,aAAatN,EAAKF,GAEjB,IAEJ4N,EAFYjW,KAAKwV,kBAAkBjN,GACjCwN,UAC+B1N,GAASvG,MAAK,SAAAoU,GAAA,OAAmB,OAAdA,EAAE1N,WAExD,IAAKyN,EACH,MAAM,IAAI1R,MAAJ,8CAAwD8D,GAKhE,OAFA4N,EAAqBzN,QAAUA,EAExByN,EAAqB7V,Q,uCAObmI,GAAK,WACduN,EAAQ9V,KAAKwV,kBAAkBjN,GACjCqN,EAA2BE,EAA3BF,YAAaG,EAAcD,EAAdC,UAEjBH,EAAYtO,SAAQ,SAAA4O,GAAA,OAAK,EAAKC,aAAaD,MAE3C9X,OAAO0N,KAAKiK,GAAWzO,SAAQ,SAAAe,GAC7B0N,EAAU1N,GAASf,SAAQ,SAAA4O,GAAA,OAAK,EAAKC,aAAaD,EAAE9V,iBAC7C2V,EAAU1N,aAGZrI,KAAKwV,kBAAkBjN,K,sCAShBA,EAAKF,GAAuB,WAAdJ,EAAc,wDACpC6N,EAAQ9V,KAAKwV,kBAAkBjN,GACjCwN,EAAcD,EAAdC,UAEJ,IAAK9N,EAGH,OAFA8N,EAAU1N,GAAS0K,KAAI,SAAAmD,GAAA,OAAKA,EAAE9V,SAAOkH,SAAQ,SAAA8O,GAAA,OAAQ,EAAKD,aAAaC,kBAChEL,EAAU1N,GAInB,IAAMgO,EAAaN,EAAU1N,GAAS6C,QAAO,SAAAgL,GAAA,OAAmB,OAAdA,EAAE1N,WAAkBuK,KAAI,SAAAmD,GAAA,OAAKA,EAAE9V,SACjF2V,EAAU1N,GAAW0N,EAAU1N,GAAS6C,QAAO,SAAAgL,GAAA,OAAmB,OAAdA,EAAE1N,WAEtD6N,EAAW/O,SAAQ,SAAA8O,GAAA,OAAQ,EAAKD,aAAaC,Q,sCAS/B7N,EAAKF,EAASG,GACtB,IAAAsN,EAAQ9V,KAAKwV,kBAAkBjN,GACjCqN,EAA2BE,EAA3BF,YAAaG,EAAcD,EAAdC,UAEXO,EAAoBP,EAAU1N,GAASvG,MAAK,SAAAoU,GAAA,OAAKA,EAAE1N,UAAYA,KAEhE8N,IAILP,EAAU1N,GAAW0N,EAAU1N,GAAS6C,QAAO,SAAAgL,GAAA,OAAKA,EAAE1N,UAAYA,KAClEsN,EAAMF,YAAN,YAAwBA,GAAxB,CAAqCU,EAAkBlW,W,mCAS5CmI,EAAKF,GAChB,QAAKrI,KAAKwV,kBAAkBjW,eAAegJ,IAI7BvI,KAAKwV,kBAAkBjN,GACjCwN,UAEiC1N,GAAS6C,QAAO,SAAAgL,GAAA,OAAmB,OAAdA,EAAE1N,WAClC6C,OAAS,I,4CASf9C,EAAKgO,EAAgBlO,GACnC,IAAAyN,EAAQ9V,KAAKwV,kBAAkBjN,GACjCwN,EAA2BD,EAA3BC,UAAWH,EAAgBE,EAAhBF,YAEf,GAAIW,aAA0BlW,MAC5BL,KAAKmW,aAAaI,GAEdlO,EACF0N,EAAU1N,GAAW0N,EAAU1N,GAAS6C,QAAO,SAAAgL,GAAA,OAAKA,EAAE9V,QAAUmW,KAEhET,EAAMF,YAAcA,EAAY1K,QAAO,SAAAgL,GAAA,OAAKA,IAAMK,SAE/C,CACL,IAAMD,EAAoBP,EAAU1N,GAASvG,MAAK,SAAAoU,GAAA,OAAKA,EAAE1N,UAAY+N,KACrEvW,KAAKmW,aAAaG,EAAkBlW,OACpC2V,EAAU1N,GAAW0N,EAAU1N,GAAS6C,QAAO,SAAAgL,GAAA,OAAKA,EAAE1N,UAAY+N,KAGpElO,IAAY0N,EAAU1N,GAASgD,eAAiB0K,EAAU1N,IACzDuN,EAAYvK,SAAWjN,OAAO0N,KAAKiK,GAAW1K,eAAiBrL,KAAKwV,kBAAkBjN,K,gCAM/E,WACRnK,OAAO0N,KAAK9L,KAAKwV,mBAAmBlO,SAAQ,SAAAiB,GACpC,IAAAuN,EAAQ,EAAKN,kBAAkBjN,GACjCqN,EAA2BE,EAA3BF,YAAaG,EAAcD,EAAdC,UAEbM,EAAa,GAEjBjY,OAAO0N,KAAKiK,GAAWzO,SAAQ,SAAAe,GAC7BgO,cAAiBA,GAAjB,EAAgCN,EAAU1N,GAAS6C,QAAO,SAAAgL,GAAA,OAAmB,OAAdA,EAAE1N,WAAkBuK,KAAI,SAAAmD,GAAA,OAAKA,EAAE9V,WAC9F2V,EAAU1N,GAAW0N,EAAU1N,GAAS6C,QAAO,SAAAgL,GAAA,OAAmB,OAAdA,EAAE1N,cAGxDsN,EAAMF,YAAc,YAAIA,GAAJ,EAAoBS,IAAYG,MAAM,EAAG,EAAKzR,yB,gCAO5D,WACR3G,OAAO0N,KAAK9L,KAAKwV,mBAAmBlO,SAAQ,SAAAiB,GAAA,OAAO,EAAKwM,iBAAiBxM,MACzEvI,KAAKyF,MAAQ,O,iCAQJ8C,GACLvI,KAAKwV,kBAAkBjW,eAAegJ,KAI1CvI,KAAKwV,kBAAkBjN,GAAO,CAC5BqN,YAAa,GACbG,UAAW,O,mCAUFxN,EAAKF,GAChBrI,KAAK0V,WAAWnN,GAEV,IACFwN,EADU/V,KAAKwV,kBAAkBjN,GACjCwN,UAEAA,EAAUxW,eAAe8I,KAI7B0N,EAAU1N,GAAW,M,2CAQFE,GACnB,GAAKvI,KAAKwV,kBAAkBjW,eAAegJ,GAA3C,CAIM,IAAAuN,EAAQ9V,KAAKwV,kBAAkBjN,GACjCqN,EAA2BE,EAA3BF,YAAaG,EAAcD,EAAdC,UAEbU,EAAuB,EAM3B,GAJArY,OAAO0N,KAAKiK,GAAWzO,SAAQ,SAAAe,GAC7BoO,GAA8CV,EAAU1N,GAASgD,YAG/DuK,EAAYvK,OAASoL,EAAuBzW,KAAK+E,oBAYrD,MARK/E,KAAKyV,eACRzV,KAAKyF,MAAMwC,KAAKM,GAChBvI,KAAKyV,cAAe,EACpBzV,KAAK2V,qBAAqBpN,IAG5BvI,KAAKyV,cAAe,EAEd,IAAIlR,MAAJ,sCAAgDgE,M,mCAQ3CnI,GACXA,EAAMkR,QACN3M,UAAQ+R,SAAWtW,EAAMmI,IAAM,0FAC/BnI,EAAM4G,QAAU,KAChB5G,EAAMuW,MAAQ,KACdvW,EAAMgV,eAAiB,S,eAIZZ,G,yaCnUToC,EAmBJ,WAAYvO,EAASa,GAAO,eAb5BA,MAAQ,KAaoB,KAP5Bb,QAAU,KAQRrI,KAAKqI,QAAUA,EACfrI,KAAKkJ,MAAQA,GAOX2N,E,WA0BJ,WAAYlU,EAAKmU,GAAc,eApB/BC,KAAO,KAoBwB,KAd/BC,MAAQ,GAcuB,KAP/B/R,cAAgB,EAQdjF,KAAK+W,KAAOpU,EACZ3C,KAAKiF,cAAgB6R,EACrB9W,KAAKiI,KAAOjI,KAAKiI,KAAK/I,KAAKc,M,sCAQzBqI,EAASa,GACX,IAAMV,EAAUU,EAAMtE,KAAKqS,WAEvBjX,KAAKgX,MAAMzX,eAAeiJ,KAI9BxI,KAAKgX,MAAMxO,GAAW,IAAIoO,EAASvO,EAASa,M,6BAQnB,WAAtBuB,IAAsB,yDAATpC,EAAS,aACnB3G,EAAM,IAAID,KAEhBrD,OAAO8Y,OAAOlX,KAAKgX,OAAO1P,SAAQ,SAAA6P,GAAQ,IAChCjO,EAAwBiO,EAAxBjO,MAAOkO,EAAiBD,EAAjBC,aACTC,GAA6B3V,EAAMwH,EAAMoO,cAAgB,IAE3D7M,IAASvB,EAAMqO,gBACjBrO,EAAM4I,aACN5I,EAAMsO,YACNH,EAAiD,GAArB,EAAKpS,gBAI9B1E,QAAQ8H,IAAY+O,IAAiB/O,IACxCa,EAAMS,iBACC,EAAKqN,MAAM9N,EAAMtE,Y,6BAUvByD,GACL,IAAMoP,EAAarZ,OAAO8Y,OAAOlX,KAAKgX,OAEtC,OADc3O,EAAUoP,EAAWvM,QAAO,SAAAiM,GAAA,OAAQA,EAAK9O,UAAYA,KAAWoP,GACjE1E,KAAI,SAAAoE,GAAA,OAAQA,EAAKjO,W,gCAO9B9K,OAAO8Y,OAAOlX,KAAKgX,OAAO1P,SAAQ,SAAA6P,GAAA,OAAQA,EAAKjO,MAAMS,aACrD3J,KAAKgX,MAAQ,O,KAOXpR,E,WAoBJ,WAAYkR,GAAc,eAb1B7R,cAAgB,EAaU,KAN1ByS,aAAe,GAOb1X,KAAKiF,cAAgB6R,EACrB9W,KAAKiI,KAAOjI,KAAKiI,KAAK/I,KAAKc,M,sCASzB2C,EAAK0F,EAASa,GACXlJ,KAAK0X,aAAanY,eAAeoD,KACpC3C,KAAK0X,aAAa/U,GAAO,IAAIkU,EAAmBlU,EAAK3C,KAAKiF,gBAG5DjF,KAAK0X,aAAa/U,GAAKyG,IAAIf,EAASa,K,4BAQhCtE,GACJ,OAAO5E,KAAKiJ,SAASnH,MAAK,SAAAoH,GAAA,OAASA,EAAMtE,OAASA,O,6BAQ7CyD,GACL,IAAMY,EAAS,GAEf,OADA7K,OAAO8Y,OAAOlX,KAAK0X,cAAcpQ,SAAQ,SAAAqQ,GAAA,OAAO1O,EAAO+B,KAAP,MAAA/B,E,sHAAA,CAAe0O,EAAI1O,OAAOZ,QACnEY,I,6BASuB,IAA3BwB,IAA2B,yDAAdlC,EAAc,aAATF,EAAS,aAC1BE,EACFvI,KAAK0X,aAAanP,GAAKN,KAAKwC,EAAMpC,GAIpCjK,OAAO8Y,OAAOlX,KAAK0X,cAAcpQ,SAAQ,SAAAqQ,GAAA,OAAOA,EAAI1P,KAAKwC,EAAMpC,Q,kCASrDE,EAAKF,EAASG,UACjBxI,KAAK0X,aAAanP,GAAKyO,MAAMxO,K,gCAOpCpK,OAAO8Y,OAAOlX,KAAK0X,cAAcpQ,SAAQ,SAAAqQ,GAAA,OAAOA,EAAIhO,aACpD3J,KAAK0X,aAAe,O,eAIT9R,G,uvBC5Nf,M,IACA,M,IACA,O,EACA,M,mDAMA,IAAMgS,EAAa,CACjBpU,MAAO,QACPqU,QAAS,UACTC,OAAQ,SACR3L,UAAW,aAOP7B,E,WAyOJ,WAAYvE,I,4FAAM,cAlOlBrB,KAAO,EAkOW,KA3NlBI,QAAU,EA2NQ,KApNlB2I,MAAQ,EAoNU,KA7MlB5I,QAAS,EA6MS,KAtMlB6I,OAAQ,EAsMU,KA/LlBrI,OAASuS,EAAWpU,MA+LF,KAxLlB8B,SAAW,KAwLO,KAjLlBC,UAAY,KAiLM,KA1KlBsI,SAAU,EA0KQ,KAnKlBiC,QAAU,KAmKQ,KA5JlBiI,OAAS,KA4JS,KArJlBC,kBAAoB,KAqJF,KA9IlBlK,UAAY,EA8IM,KAvIlBmK,UAAY,EAuIM,KAhIlBC,QAAU,EAgIQ,KAzHlBC,YAAc,EAyHI,KAlHlBC,UAAY,EAkHM,KA1GlBC,WAAa,EA0GK,KAnGlBC,cAAgB,KAmGE,KA5FlBC,iBAAmB,KA4FD,KArFlBC,iBAAmB,KAqFD,KA9ElBtK,SAAU,EA8EQ,KAvElBC,WAAa,KAuEK,KAhElBsK,iBAAmB,KAgED,KAzDlBC,oBAAsB,KAyDJ,KAlDlBC,6BAA+B,KAkDb,KA3ClBC,UAAY,KA2CM,KApClBC,WAAY,EAoCM,KA7BlBC,YAAc,IAAIrX,KA6BA,KAtBlBsX,UAAW,EAsBO,IAEdnU,EAeEmB,EAfFnB,GACAmK,EAcEhJ,EAdFgJ,OACAyB,EAaEzK,EAbFyK,OACApQ,EAYE2F,EAZF3F,MACA+F,EAWEJ,EAXFI,OACAyI,EAUE7I,EAVF6I,KACAC,EASE9I,EATF8I,KACAzI,EAQEL,EARFK,MACA4K,EAOEjL,EAPFiL,SACAC,EAMElL,EANFkL,OACAH,EAKE/K,EALF+K,aACAL,EAIE1K,EAJF0K,gBACAC,EAGE3K,EAHF2K,gBACAC,EAEE5K,EAFF4K,gBACAC,EACE7K,EADF6K,mBAIF5Q,KAAK0E,IAAoB,iBAAPE,EAAkBA,EAAKD,UAAQC,KAGjD5E,KAAK8P,QAAUU,EACfxQ,KAAK+X,OAAS3X,EAGd+F,IAAWnG,KAAK8E,QAAUqB,GAC1ByI,IAAS5O,KAAKyN,MAAQmB,GACtBxI,IAAUpG,KAAK6E,OAASuB,GACxByI,IAAS7O,KAAK0N,MAAQmB,GACtBmC,IAAahR,KAAKiY,UAAYjH,GAC9BC,IAAWjR,KAAKkY,QAAUjH,GAC1BjR,KAAKsY,cAAgBxH,EACrB9Q,KAAKuY,iBAAmB9H,EACxBzQ,KAAKwY,iBAAmB9H,EACxB1Q,KAAKyY,iBAAmB9H,EACxB3Q,KAAK0Y,oBAAsB9H,EAC3B5Q,KAAK6N,QAAUtN,QAAQwO,GAEvB/O,KAAKkY,QAAUlY,KAAK6N,QAAU7N,KAAK+X,OAAOlI,SAAW7P,KAAK8P,QAAQD,SAClE7P,KAAK8N,UAAY9N,KAAKkY,QAAUlY,KAAKiY,UACrCjY,KAAK6Y,UAAY7Y,KAAK8N,UAAY9N,KAAKkY,QAGnClY,KAAK6N,UACP7N,KAAK+X,OAAOiB,aAAehZ,KAAKyN,MAChCzN,KAAKiZ,SAASjZ,KAAK0N,OACnB1N,KAAK+X,OAAOtQ,iBAAiB,QAASzH,KAAKkZ,gBAIzCzU,UAAO+J,qBACTxO,KAAKsF,SAAWb,UAAO+N,UACvBxS,KAAKuF,UAAYvF,KAAKsF,SAASoC,aAC/B1H,KAAKuF,UAAUoC,KAAKC,eAAe5H,KAAK6E,OAAS,EAAI7E,KAAK8E,QAAS9E,KAAKsF,SAASuC,aAG7E7H,KAAK6N,UACP7N,KAAK2Y,6BAA+B3Y,KAAKsF,SAAS6T,yBAAyBnZ,KAAK+X,QAChF/X,KAAK2Y,6BAA6B7Q,QAAQ9H,KAAKuF,aAInDvF,KAAKoZ,eAAiBpZ,KAAKoZ,eAAela,KAAKc,MAC/CA,KAAKqZ,cAAgBrZ,KAAKqZ,cAAcna,KAAKc,M,yCAMxC,WACL,GAAKA,KAAK6N,UAAW7N,KAAK8R,aAAe9R,KAAKqH,UAAYuQ,EAAWzL,UAArE,CAIA,IAAM8I,EAAmB,SAAnBA,IACJ,EAAKqD,gBACL,EAAKP,OAAOzC,oBAAoB,iBAAkBL,IAGpDjV,KAAK+X,OAAOtQ,iBAAiB,iBAAkBwN,GAC/CjV,KAAK+X,OAAOlQ,YAAc,EAEtB7H,KAAK+X,OAAO1C,YAAc,GAC5BJ,O,6BAUF,OAAIjV,KAAK8R,YACA9R,MAGTA,KAAK6N,QAAU7N,KAAKsZ,aAAetZ,KAAKuZ,cAGxCvZ,KAAKqY,WAAarY,KAAKsF,SAASuC,YAChC7H,KAAKqF,OAASuS,EAAWC,QAElB7X,Q,8BASP,OAAKA,KAAK8R,aAKV9R,KAAKoR,WAEDpR,KAAK6N,SACP7N,KAAK+X,OAAOzC,oBAAoB,QAAStV,KAAKqZ,eAC9CrZ,KAAKwZ,iBACLxZ,KAAK+X,OAAOzG,UAEZtR,KAAKoY,UAAY,EACjBpY,KAAKyZ,sBAGPzZ,KAAKmY,YAAcnY,KAAK6R,OACxB7R,KAAKqF,OAASuS,EAAWE,OAElB9X,MAlBEA,O,6BA2BT,OAAKA,KAAK8R,aAAgB9R,KAAKwX,YAK/BxX,KAAKoR,WAEDpR,KAAK6N,SACP7N,KAAK+X,OAAOzC,oBAAoB,QAAStV,KAAK0Z,UAC9C1Z,KAAKwZ,iBACLxZ,KAAK+X,OAAOzG,QACZtR,KAAK+X,OAAOlQ,YAAc7H,KAAKiY,WAAa,IAE5CjY,KAAKmY,YAAc,EACnBnY,KAAKoY,UAAY,EACjBpY,KAAKyZ,sBAGPzZ,KAAK8Y,YAAc,IAAIrX,KAEvBzB,KAAKqF,OAASuS,EAAWpU,MAElBxD,MArBEA,O,6BAsCT,OARAA,KAAKoR,WAGLpR,KAAKuF,UAAUoC,KAAKC,eAAe,EAAG5H,KAAKsF,SAASuC,aAGpD7H,KAAK6E,QAAS,EAEP7E,O,+BAiBP,OARAA,KAAKoR,WAGLpR,KAAKuF,UAAUoC,KAAKC,eAAe5H,KAAK8E,QAAS9E,KAAKsF,SAASuC,aAG/D7H,KAAK6E,QAAS,EAEP7E,O,6BAQF+I,GAEL,YAAmB,IAARA,EACF/I,KAAK8E,SAId9E,KAAKoR,WAGLpR,KAAKuF,UAAUoC,KAAKC,eAAe5H,KAAK6E,OAAS,EAAIkE,EAAK/I,KAAKsF,SAASuC,aAGxE7H,KAAK8E,QAAUiE,EAER/I,Q,2BAUJ0R,EAAI7B,GAA2B,WAAjB3J,EAAiB,uDAAV,SAyBxB,OAvBIlG,KAAKkO,SACPlO,KAAKoR,WAGPpR,KAAKkO,SAAU,EAEF,WAAThI,EACFlG,KAAKuF,UAAUoC,KAAKgS,wBAAwBjI,EAAI1R,KAAKsF,SAASuC,YAAcgI,GAE5E7P,KAAKuF,UAAUoC,KAAKiS,6BAA6BlI,EAAI1R,KAAKsF,SAASuC,YAAcgI,GAGnF7P,KAAKmO,WAAa0L,UAAYvO,YAAW,WACvC,EAAKnF,OAAOuL,GAEZmI,UAAYjI,aAAa,EAAKzD,YAE9B,EAAKA,WAAa,KAClB,EAAKD,SAAU,EAEf,EAAKuK,kBAAoB,EAAKA,iBAAiB,KACnC,IAAX5I,GAEI7P,O,iCAQP,OAAKA,KAAKkO,SAIVlO,KAAKuF,UAAUoC,KAAKmS,sBAAsB9Z,KAAKsF,SAASuC,aAEpD7H,KAAKmO,aACP0L,UAAYjI,aAAa5R,KAAKmO,YAC9BnO,KAAKmO,WAAa,MAGpBnO,KAAKkO,SAAU,EACflO,KAAKmG,OAAOnG,KAAKuF,UAAUoC,KAAKhJ,OAEzBqB,MAbEA,O,2BAqBN4O,GAEH,QAAoB,IAATA,EACT,OAAO5O,KAAKyN,MAMd,GAHAzN,KAAKyN,MAAQmB,EACb5O,KAAKoY,UAAYpY,KAAK6R,OAElB7R,KAAK8R,YACP,GAAI9R,KAAK6N,SAGP,GAFA7N,KAAK+X,OAAOiB,aAAepK,EAEvB5O,KAAK6Y,UAAW,CAClB7Y,KAAKwZ,iBADa,MAECxZ,KAAK+Z,eAAjBlK,EAFW,UAGlB7P,KAAK4Y,UAAYiB,UAAYvO,WAAWtL,KAAK0Z,SAAsB,IAAX7J,EAAmBtO,KAAKyY,IAAIpL,UAGtF5O,KAAKqY,WAAarY,KAAKsF,SAASuC,YAChC7H,KAAKgY,mBAAsBhY,KAAKgY,kBAAkBgB,aAAapR,eAAegH,EAAM5O,KAAKsF,SAASuC,aAItG,OAAO7H,O,2BAQJ6R,GAEH,QAAoB,IAATA,EAAsB,CAC/B,GAAI7R,KAAK6N,QACP,OAAO7N,KAAK+X,OAAOlQ,YAGrB,IAAMoS,EAAWja,KAAK8R,YAAc9R,KAAKsF,SAASuC,YAAc7H,KAAKqY,WAAa,EAC5E6B,EAAcla,KAAKoY,UAAYpY,KAAKoY,UAAYpY,KAAKmY,YAAc,EACzE,OAAOnY,KAAKmY,aAAe+B,EAAcD,EAAWja,KAAKyN,OAI3D,GAAIoE,EAAO7R,KAAKiY,WAAapG,EAAO7R,KAAKkY,QACvC,OAAOlY,KAIT,IAAM8R,EAAY9R,KAAK8R,YAYvB,OAVIA,GACF9R,KAAKsR,QAGPtR,KAAKmY,YAActG,EAEfC,GACF9R,KAAKyP,OAGAzP,O,2BAQJ6O,GACH,MAAoB,kBAATA,EACF7O,KAAK0N,OAGd1N,KAAK0N,MAAQmB,EACb7O,KAAKiZ,SAASpK,GAEP7O,Q,gCASP,OAAIA,KAAKqF,SAAWuS,EAAWzL,UACtBnM,MAITA,KAAKmJ,OAELnJ,KAAKma,0BACLna,KAAK+X,QAAU/X,KAAK+X,OAAOzC,oBAAoB,QAAStV,KAAKkZ,eAE7DlZ,KAAKuF,WAAavF,KAAKuF,UAAU6U,aAEjCpa,KAAK8P,QAAU,KACf9P,KAAK+X,OAAS,KACd/X,KAAKsF,SAAW,KAChBtF,KAAKuF,UAAY,KAGjBvF,KAAKqF,OAASuS,EAAWzL,UAEzBnM,KAAKwY,kBAAoBxY,KAAKwY,iBAAiBxY,MAExCA,Q,2BAQP,OAAOA,KAAK0E,M,8BAQZ,OAAO1E,KAAK6E,S,8BAQZ,OAAO7E,KAAKqF,S,iCAQZ,OAAOrF,KAAK8N,Y,kCAQZ,OAAO9N,KAAKqF,SAAWuS,EAAWC,U,iCAQlC,OAAO7X,KAAKqF,SAAWuS,EAAWE,S,mCAQlC,OAAO9X,KAAK8Y,c,gCAOR9Y,KAAKqF,SAAWuS,EAAWzL,YAI/BnM,KAAK+Y,UAAW,K,gCAOZ/Y,KAAKqF,SAAWuS,EAAWzL,YAI/BnM,KAAK+Y,UAAW,K,qCAQhB,OAAO/Y,KAAK+Y,W,oCAQAlI,GACZ7Q,KAAK0Y,qBAAuB1Y,KAAK0Y,oBAAoB1Y,KAAM6Q,K,qCAS3D,IAAIgB,EAAOtQ,KAAK8Y,IAAI,EAAGra,KAAKmY,YAAc,EAAInY,KAAKmY,YAAcnY,KAAKiY,WACpEpI,EAAW7P,KAAKkY,QAAUlY,KAAKiY,UAGjC,MAAO,CAACpG,EAAMhC,EAFU,IAAXA,EAAmB7P,KAAKyN,S,oCASzB,MACWzN,KAAK+Z,eADhB,SACPlI,EADO,KACDhC,EADC,KAIZ7P,KAAKgY,kBAAoBhY,KAAKsF,SAASgV,qBAGvCta,KAAKgY,kBAAkBxH,OAASxQ,KAAK8P,QACrC9P,KAAKgY,kBAAkBgB,aAAapR,eAAe5H,KAAKyN,MAAOzN,KAAKsF,SAASuC,aAC7E7H,KAAKiZ,SAASjZ,KAAK0N,OAGnB1N,KAAKgY,kBAAkBlQ,QAAQ9H,KAAKuF,WAGpCvF,KAAKgY,kBAAkBvQ,iBAAiB,QAASzH,KAAKoZ,gBAEtD,IAAMmB,EAAYva,KAAKsF,SAASuC,iBAGY,IAAjC7H,KAAKgY,kBAAkBwC,MAChCxa,KAAKgY,kBAAkBwC,MAAMD,EAAW1I,EAAM7R,KAAK0N,WAAQ1E,EAAY6G,GAEvE7P,KAAKgY,kBAAkByC,YAAYF,EAAW1I,EAAM7R,KAAK0N,WAAQ1E,EAAY6G,K,mCAQpE,MACa7P,KAAK+Z,eADlB,SACNlI,EADM,KACE6I,EADF,KAGX1a,KAAK+X,OAAOlQ,YAAcgK,EAEtB7R,KAAK6Y,UACP7Y,KAAK4Y,UAAYiB,UAAYvO,WAAWtL,KAAKqZ,cAAeqB,GAE5D1a,KAAK+X,OAAOtQ,iBAAiB,QAASzH,KAAKqZ,eAG7CrZ,KAAK+X,OAAOtI,S,uCAQZzP,KAAK8Y,YAAc,IAAIrX,KAGvBzB,KAAKmY,YAAc,EACnBnY,KAAKoY,UAAY,EAGjBpY,KAAKyZ,qBAGLzZ,KAAKqF,OAASuS,EAAWpU,MAGzBxD,KAAKuY,kBAAoBvY,KAAKuY,iBAAiBvY,Q,sCAQ3CA,KAAK0N,MACP1N,KAAKmJ,OAAOsG,QAEZzP,KAAKmJ,OACLnJ,KAAKqF,OAASuS,EAAWpU,MACzBxD,KAAKuY,kBAAoBvY,KAAKuY,iBAAiBvY,S,uCAS5CA,KAAK4Y,YAIViB,UAAYjI,aAAa5R,KAAK4Y,WAC9B5Y,KAAK4Y,UAAY,Q,8BAQjB,OAAO5Y,KAAKuF,Y,2CAQPvF,KAAKgY,yBAIiC,IAAhChY,KAAKgY,kBAAkB7O,KAChCnJ,KAAKgY,kBAAkB7O,OAEvBnJ,KAAKgY,kBAAkB2C,eAGzB3a,KAAKgY,kBAAkBoC,aACvBpa,KAAKgY,kBAAkB1C,oBAAoB,QAAStV,KAAKoZ,gBACzDpZ,KAAKgY,kBAAoB,Q,gDAQpBhY,KAAK2Y,+BAIV3Y,KAAK2Y,6BAA6ByB,aAClCpa,KAAK2Y,6BAA+B,Q,+BAQ7B9J,GACH7O,KAAK6N,QACP7N,KAAK+X,OAAOlJ,KAAOA,GAEnB7O,KAAKgY,kBAAkBnJ,KAAOA,EAE1BA,IACF7O,KAAKgY,kBAAkB4C,UAAY5a,KAAKiY,UACxCjY,KAAKgY,kBAAkB6C,QAAU7a,KAAKkY,c,OAM5BvN,QAATL,E,EAAkBsN,c,uUCl5B3B,IAiCMkD,E,WAiCJ,c,4FAAc,cA1BdC,QAAU,KA0BI,KAnBdC,0BAA2B,EAmBb,KAZdC,gBAAkB,GAYJ,KALdC,SAAW,EAMTlb,KAAKmb,eAAiBnb,KAAKmb,eAAejc,KAAKc,M,yCAO/C,GAAKob,SAAUpb,KAAK+a,QAApB,CAIA,IAAIM,EAAOrb,KAAKsb,SA9EEC,4uBA+ElB,GAAa,OAATF,EAAJ,CAIA,IAAIG,EAAYxb,KAAKyb,iBAAiBJ,GACpB,OAAdG,IAIJxb,KAAK+a,QAAU,IAAIK,OAAOI,GAC1Bxb,KAAK+a,QAAQtT,iBAAiB,UAAWzH,KAAKmb,gBAC9Cnb,KAAKgb,0BAA2B,O,+BASzBU,GACP,IAAIL,EAAO,KAEX,IACEA,EAAO,IAAIM,KAAK,CAACD,GAAS,CAAExV,KAAM,2BAClC,MAAO0V,GACP,IAAIC,EAAkB,KAEK,oBAAhBC,YACTD,EAAkBC,YACoB,oBAAtBC,oBAChBF,EAAkBE,oBAGpBV,EAAO,IAAIQ,GACNG,OAAON,GACZL,EAAOA,EAAKY,UAGd,OAAOZ,I,uCASQa,GACf,MAAmB,oBAARC,KAAuBA,IAAIC,gBAC7BD,IAAIC,gBAAgBF,GACG,oBAAdG,UACTA,UAAUD,gBAAgBF,GAG5B,O,qCAQMN,GACb,IAAMU,EAAWtc,KAAKib,gBAAgBW,EAAEtI,KAAKiJ,SAEzCD,GAAYA,EAASE,IACvBF,EAASE,KAGNF,EAASG,eACLzc,KAAKib,gBAAgBW,EAAEtI,KAAKiJ,W,kJAU5BD,EAAUzM,GACnB,OAAK7P,KAAKgb,0BAIVhb,KAAKkb,SAAWlb,KAAKkb,SAAW,EAChClb,KAAKib,gBAAgBjb,KAAKkb,UAAY,CAAEsB,GAAIF,EAAUG,QAAQ,GAC9Dzc,KAAK+a,QAAQ2B,YAAY,CAAEC,QAAS,aAAcJ,QAASvc,KAAKkb,SAAUrL,SAAUA,IAC7E7P,KAAKkb,UANH5P,WAAWgR,EAAUzM,O,kJAanB+M,GACX,IAAK5c,KAAKgb,yBACR,OAAOpJ,aAAagL,GAGtB5c,KAAK+a,QAAQ2B,YAAY,CAAEC,QAAS,eAAgBJ,QAASK,WACtD5c,KAAKib,gBAAgB2B,O,mJASlBN,EAAUzM,GACpB,OAAK7P,KAAKgb,0BAIVhb,KAAKkb,SAAWlb,KAAKkb,SAAW,EAChClb,KAAKib,gBAAgBjb,KAAKkb,UAAY,CAAEsB,GAAIF,EAAUG,QAAQ,GAC9Dzc,KAAK+a,QAAQ2B,YAAY,CAAEC,QAAS,cAAeJ,QAASvc,KAAKkb,SAAUrL,SAAUA,IAC9E7P,KAAKkb,UANHlT,YAAYsU,EAAUzM,O,oCAanBgN,GACZ,IAAK7c,KAAKgb,yBACR,OAAOpJ,aAAaiL,GAGtB7c,KAAK+a,QAAQ2B,YAAY,CAAEC,QAAS,eAAgBJ,QAASM,WACtD7c,KAAKib,gBAAgB4B,K,kCAOxB7c,KAAK+a,UACP/a,KAAK+a,QAAQzF,oBAAoB,UAAWtV,KAAKmb,gBACjDnb,KAAK+a,QAAQ/Q,YACbhK,KAAK+a,QAAU,MAGjB/a,KAAKgb,0BAA2B,EAChChb,KAAKib,gBAAkB,GACvBjb,KAAKkb,SAAW,M,eAIL,IAAIJ","file":"musquito-2.0.0-beta.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"$buzz\"] = factory();\n\telse\n\t\troot[\"$buzz\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","/**\n * Contains helper methods.\n */\nclass Utility {\n\n  /**\n   * The navigator object.\n   * @type {Navigator}\n   * @private\n   */\n  _navigator = null;\n\n  /**\n   * The AudioContext type.\n   * @type {Function}\n   * @private\n   */\n  _contextType = null;\n\n  /**\n   * Dictionary of audio formats and their support status.\n   * @type {object}\n   * @private\n   */\n  _formats = {};\n\n  /**\n   * User agent.\n   * @private\n   */\n  _userAgent = null;\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    if (typeof navigator !== 'undefined') {\n      this._navigator = navigator;\n      this._userAgent = navigator.userAgent;\n    }\n\n    // Set the available Web Audio Context type available in browser.\n    if (typeof AudioContext !== 'undefined') {\n      this._contextType = AudioContext;\n    } else if (typeof webkitAudioContext !== 'undefined') {\n      this._contextType = webkitAudioContext;\n    }\n\n    // Determine the supported audio formats.\n    let audio = new Audio();\n\n    this._formats = {\n      mp3: Boolean(audio.canPlayType('audio/mp3;').replace(/^no$/, '')),\n      mpeg: Boolean(audio.canPlayType('audio/mpeg;').replace(/^no$/, '')),\n      opus: Boolean(audio.canPlayType('audio/ogg; codecs=\"opus\"').replace(/^no$/, '')),\n      ogg: Boolean(audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n      oga: Boolean(audio.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n      wav: Boolean(audio.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, '')),\n      aac: Boolean(audio.canPlayType('audio/aac;').replace(/^no$/, '')),\n      caf: Boolean(audio.canPlayType('audio/x-caf;').replace(/^no$/, '')),\n      m4a: Boolean((audio.canPlayType('audio/x-m4a;') ||\n        audio.canPlayType('audio/m4a;') ||\n        audio.canPlayType('audio/aac;')).replace(/^no$/, '')),\n      mp4: Boolean((audio.canPlayType('audio/x-mp4;') ||\n        audio.canPlayType('audio/mp4;') ||\n        audio.canPlayType('audio/aac;')).replace(/^no$/, '')),\n      weba: Boolean(audio.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n      webm: Boolean(audio.canPlayType('audio/webm; codecs=\"vorbis\"').replace(/^no$/, '')),\n      dolby: Boolean(audio.canPlayType('audio/mp4; codecs=\"ec-3\"').replace(/^no$/, '')),\n      flac: Boolean((audio.canPlayType('audio/x-flac;') || audio.canPlayType('audio/flac;')).replace(/^no$/, ''))\n    };\n\n    audio = null;\n  }\n\n  /**\n   * Returns an unique id (credit: https://howlerjs.com).\n   * @return {number}\n   */\n  id() {\n    return Math.round(Date.now() * Math.random());\n  }\n\n  /**\n   * Returns the available context type.\n   * @return {Function}\n   */\n  getContextType() {\n    return this._contextType;\n  }\n\n  /**\n   * Instantiates and returns the audio context.\n   * @return {AudioContext|webkitAudioContext}\n   */\n  getContext() {\n    return new this._contextType();\n  }\n\n  /**\n   * Returns the supported audio formats.\n   * @return {Object}\n   */\n  supportedFormats() {\n    return this._formats;\n  }\n\n  /**\n   * Returns true if the passed format is supported.\n   * @param {string} format The audio format ex. \"mp3\"\n   * @return {boolean}\n   */\n  isFormatSupported(format) {\n    return Boolean(this._formats[format]);\n  }\n\n  /**\n   * Returns the first supported format from the passed array.\n   * @param {string[]} formats Array of audio formats\n   * @return {string}\n   */\n  getSupportedFormat(formats) {\n    return formats.find(format => this.isFormatSupported(format));\n  }\n\n  /**\n   * Returns true if the audio source is supported.\n   * @param {string} source The audio source url or base64 string\n   * @return {boolean}\n   */\n  isSourceSupported(source) {\n    let ext = this.isBase64(source) ?\n      (/^data:audio\\/([^;,]+);/i).exec(source) :\n      (/^.+\\.([^.]+)$/).exec(source);\n\n    ext = (/^.+\\.([^.]+)$/).exec(source);\n    return ext ? this.isFormatSupported(ext[1].toLowerCase()) : false;\n  }\n\n  /**\n   * Returns the first supported audio source from the passed array.\n   * @param {string[]} sources Array of audio sources. The audio source could be either url or base64 string.\n   * @return {string}\n   */\n  getSupportedSource(sources) {\n    return sources.find(source => this.isSourceSupported(source));\n  }\n\n  /**\n   * Returns whether the passed string is a base64 string or not.\n   * @param {string} str Base64 audio string\n   * @return {boolean}\n   */\n  isBase64(str) {\n    return (/^data:[^;]+;base64,/).test(str);\n  }\n\n  /**\n   * Returns true if the platform is mobile.\n   * @return {boolean}\n   * @private\n   */\n  _isMobile() {\n    if (!this._navigator) {\n      return false;\n    }\n\n    return (/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i).test(this._userAgent);\n  }\n\n  /**\n   * Returns true if the platform is touch supported.\n   * @return {boolean}\n   * @private\n   */\n  _isTouch() {\n    return typeof window !== 'undefined' && (Boolean(('ontouchend' in window) ||\n      (this._navigator && this._navigator.maxTouchPoints > 0) ||\n      (this._navigator && this._navigator.msMaxTouchPoints > 0)));\n  }\n\n  /**\n   * Returns true if the user agent is IE.\n   * @return {boolean}\n   */\n  isIE() {\n    return Boolean(this._userAgent && (/MSIE |Trident\\//).test(this._userAgent));\n  }\n}\n\nexport default new Utility();\n\n","import DownloadStatus from './DownloadStatus';\n\n/**\n * Represents the download result of an audio.\n * @class\n */\nclass DownloadResult {\n\n  /**\n   * The url of the audio resource\n   * @type {string|null}\n   */\n  url = null;\n\n  /**\n   * AudioBuffer or Html5Audio element\n   * @type {AudioBuffer|Audio}\n   */\n  value = null;\n\n  /**\n   * Download error\n   * @type {any}\n   */\n  error = null;\n\n  /**\n   * Success or failure status of download.\n   * @type {DownloadStatus}\n   */\n  status = null;\n\n  /**\n   * @param {string|null} url The url of the audio resource\n   * @param {AudioBuffer|Audio} [value] AudioBuffer or Html5Audio element\n   * @param {*} [error] Download error\n   */\n  constructor(url, value, error) {\n    this.url = url;\n    this.value = value;\n    this.error = error || null;\n    this.status = error ? DownloadStatus.Failure : DownloadStatus.Success;\n  }\n}\n\nexport default DownloadResult;\n","import BufferLoader from './BufferLoader';\nimport MediaLoader  from './MediaLoader';\nimport emitter      from './Emitter';\nimport Heap         from './Heap';\nimport Queue        from './Queue';\nimport utility      from './Utility';\nimport Sound        from './Sound';\n\n/**\n * Enum that represents the different type of errors thrown by Engine and Buzzes.\n * @enum {string}\n */\nconst ErrorType = {\n  NoAudio: 'no-audio',\n  LoadError: 'load',\n  PlayError: 'play',\n  EngineError: 'engine'\n};\n\n/**\n * Represents the different states of the audio engine.\n * @enum {string}\n */\nconst EngineState = {\n  NotReady: 'notready',\n  Ready: 'ready',\n  Suspending: 'suspending',\n  Suspended: 'suspended',\n  Resuming: 'resuming',\n  Destroying: 'destroying',\n  Done: 'done',\n  NoAudio: 'no-audio'\n};\n\n/**\n * Enum that represents the different events by engine.\n * @enum {string}\n */\nconst EngineEvents = {\n  Add: 'add',\n  Remove: 'remove',\n  Volume: 'volume',\n  Mute: 'mute',\n  Pause: 'pause',\n  Stop: 'stop',\n  Suspend: 'suspend',\n  Resume: 'resume',\n  Error: 'error',\n  Done: 'done'\n};\n\n/**\n * Array of event names.\n * @type {string[]}\n */\nconst userInputEventNames = [\n  'click',\n  'contextmenu',\n  'auxclick',\n  'dblclick',\n  'mousedown',\n  'mouseup',\n  'pointerup',\n  'touchend',\n  'keydown',\n  'keyup'\n];\n\n/**\n * The audio engine that orchestrates all the sounds.\n * @class\n */\nclass Engine {\n\n  /**\n   * Unique id of the engine.\n   * @type {number}\n   * @private\n   */\n  _id = utility.id();\n\n  /**\n   * Represents whether the audio engine is currently muted or not.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * Represents the global volume.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * Maximum number of HTML5 audio objects allowed for a url.\n   * @type {number}\n   * @private\n   */\n  _maxNodesPerSource = 10;\n\n  /**\n   * The heap clean-up period.\n   * @type {number}\n   * @private\n   */\n  _cleanUpInterval = 5;\n\n  /**\n   * Inactive time of sound.\n   * @type {number}\n   * @private\n   */\n  _inactiveTime = 2;\n\n  /**\n   * Auto-enables audio in first user interaction.\n   * @type {boolean}\n   * @private\n   */\n  _autoEnable = true;\n\n  /**\n   * The clean-up interval id.\n   * @type {number|null}\n   * @private\n   */\n  _intervalId = null;\n\n  /**\n   * True if Web Audio API is available.\n   * @type {boolean}\n   * @private\n   */\n  _isAudioAvailable = false;\n\n  /**\n   * Represents the current state of the engine.\n   * @type {EngineState}\n   * @private\n   */\n  _state = EngineState.NotReady;\n\n  /**\n   * The Web Audio API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * The master gain node.\n   * @type {GainNode}\n   * @private\n   */\n  _gainNode = null;\n\n  /**\n   * The action queue.\n   * @type {Queue}\n   * @private\n   */\n  _queue = null;\n\n  /**\n   * The sound heap.\n   * @type {Heap}\n   * @private\n   */\n  _heap = null;\n\n  /**\n   * Loader - the component that loads audio buffers with audio data.\n   * @type {BufferLoader}\n   * @private\n   */\n  _bufferLoader = null;\n\n  /**\n   * MediaLoader - the component that loads HTML5 audio nodes with audio.\n   * @type {MediaLoader}\n   * @private\n   */\n  _mediaLoader = null;\n\n  /**\n   * Instantiates the heap and action queue.\n   * @constructor\n   */\n  constructor() {\n    this._heap = new Heap(this._inactiveTime);\n    this._queue = new Queue();\n    this._resumeAndRemoveListeners = this._resumeAndRemoveListeners.bind(this);\n  }\n\n  /**\n   * Instantiate the audio context and other dependencies.\n   * @param {object} [args] Input parameters object.\n   * @param {number} [args.volume = 1.0] The global volume of the sound engine.\n   * @param {boolean} [args.muted = false] Stay muted initially or not.\n   * @param {number} [args.maxNodesPerSource = 10] Maximum number of HTML5 audio objects allowed for a url.\n   * @param {number} [args.cleanUpInterval = 5] The heap clean-up interval period in minutes.\n   * @param {boolean} [args.autoEnable = true] Auto-enables audio in first user interaction.\n   * @param {function} [args.onadd] Event-handler for the \"add\" event.\n   * @param {function} [args.onremove] Event-handler for the \"remove\" event.\n   * @param {function} [args.onstop] Event-handler for the \"stop\" event.\n   * @param {function} [args.onpause] Event-handler for the \"pause\" event.\n   * @param {function} [args.onmute] Event-handler for the \"mute\" event.\n   * @param {function} [args.onvolume] Event-handler for the \"volume\" event.\n   * @param {function} [args.onsuspend] Event-handler for the \"suspend\" event.\n   * @param {function} [args.onresume] Event-handler for the \"resume\" event.\n   * @param {function} [args.onerror] Event-handler for the \"error\" event.\n   * @param {function} [args.ondone] Event-handler for the \"done\" event.\n   * @return {Engine}\n   */\n  setup(args) {\n    // If the setup is already done return.\n    if (this._state !== EngineState.NotReady) {\n      return this;\n    }\n\n    this._context = utility.getContext();\n\n    // Determine the audio stuff available in the current platform and set the flags accordingly.\n    this._isAudioAvailable = Boolean(this._context);\n\n    // If no Web Audio and HTML5 audio is available fire an error event.\n    if (!this._isAudioAvailable) {\n      this._state = EngineState.NoAudio;\n      this._fire(EngineEvents.Error, { type: ErrorType.NoAudio, error: 'Web Audio API is not available' });\n      return this;\n    }\n\n    // Read the input parameters from the options.\n    const {\n      volume,\n      muted,\n      maxNodesPerSource,\n      cleanUpInterval,\n      autoEnable,\n      onadd,\n      onremove,\n      onstop,\n      onpause,\n      onmute,\n      onvolume,\n      onsuspend,\n      onresume,\n      onerror,\n      ondone\n    } = args || {};\n\n    // Set the properties from the read parameters.\n    typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (this._volume = volume);\n    typeof muted === 'boolean' && (this._muted = muted);\n    typeof maxNodesPerSource === 'number' && (this._maxNodesPerSource = maxNodesPerSource);\n    typeof cleanUpInterval === 'number' && (this._cleanUpInterval = cleanUpInterval);\n    typeof autoEnable === 'boolean' && (this._autoEnable = autoEnable);\n    typeof onadd === 'function' && this.on(EngineEvents.Add, onadd);\n    typeof onremove === 'function' && this.on(EngineEvents.Remove, onremove);\n    typeof onstop === 'function' && this.on(EngineEvents.Stop, onstop);\n    typeof onpause === 'function' && this.on(EngineEvents.Pause, onpause);\n    typeof onmute === 'function' && this.on(EngineEvents.Mute, onmute);\n    typeof onvolume === 'function' && this.on(EngineEvents.Volume, onvolume);\n    typeof onsuspend === 'function' && this.on(EngineEvents.Suspend, onsuspend);\n    typeof onresume === 'function' && this.on(EngineEvents.Resume, onresume);\n    typeof onerror === 'function' && this.on(EngineEvents.Error, onerror);\n    typeof ondone === 'function' && this.on(EngineEvents.Done, ondone);\n\n    // Create the buffer loader.\n    this._bufferLoader = new BufferLoader(this._context);\n\n    // Create the media loader.\n    this._mediaLoader = new MediaLoader(this._maxNodesPerSource, this._heap);\n\n    // Auto-enable audio in first user interaction.\n    // https://developers.google.com/web/updates/2018/11/web-audio-autoplay#moving-forward\n    if (this._autoEnable && this._context.state === 'suspended') {\n      userInputEventNames.forEach(eventName => document.addEventListener(eventName, this._resumeAndRemoveListeners));\n    }\n\n    // Create the audio graph.\n    this._gainNode = this._context.createGain();\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n    this._gainNode.connect(this._context.destination);\n\n    this._intervalId = window.setInterval(this._heap.free, this._cleanUpInterval * 60 * 1000);\n\n    this._state = this._context.state !== 'suspended' ? EngineState.Ready : EngineState.Suspended;\n\n    return this;\n  }\n\n  /**\n   * Loads single or multiple audio resources into audio buffers and returns them.\n   * @param {string|string[]} urls Single or array of audio urls.\n   * @param {function} [progressCallback] The callback that is called to intimate the percentage downloaded.\n   * @return {Promise}\n   */\n  load(urls, progressCallback) {\n    return this._bufferLoader.load(urls, progressCallback);\n  }\n\n  /**\n   * Loads HTML5 audio nodes for the passed urls.\n   * @param {string|string[]} urls Single or array of audio urls.\n   * @return {Promise<DownloadResult|Array<DownloadResult>>}\n   */\n  loadMedia(urls) {\n    return this._mediaLoader.load(urls);\n  }\n\n  /**\n   * Loads audio node for group.\n   * @param {string} url The audio file url.\n   * @param {number} groupId The group id.\n   * @return {Promise<DownloadResult>}\n   */\n  allocateForGroup(url, groupId) {\n    return this._mediaLoader.allocateForGroup(url, groupId);\n  }\n\n  /**\n   * Allocates an audio node for sound and returns it.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number} soundId The sound id.\n   * @return {Audio}\n   */\n  allocateForSound(src, groupId, soundId) {\n    return this._mediaLoader.allocateForSound(src, groupId, soundId);\n  }\n\n  /**\n   * Unloads single or multiple loaded audio buffers from cache.\n   * @param {string|string[]} [urls] Single or array of audio urls.\n   * @return {Engine}\n   */\n  unload(urls) {\n    if (urls) {\n      this._bufferLoader.unload(urls);\n      return this;\n    }\n\n    this._bufferLoader.unload();\n\n    return this;\n  }\n\n  /**\n   * Releases audio nodes allocated for the passed urls.\n   * @param {string|string[]} [urls] Single or array of audio urls.\n   * @return {Engine}\n   */\n  unloadMedia(urls) {\n    if (urls) {\n      this._mediaLoader.unload(urls);\n      return this;\n    }\n\n    this._mediaLoader.unload();\n\n    return this;\n  }\n\n  /**\n   * Releases the allocated audio node for the group.\n   * @param {string} url The audio file url.\n   * @param {number} groupId The group id.\n   * @param {boolean} [free = false] Pass true to release only free audio nodes.\n   * @return {Engine}\n   */\n  releaseForGroup(url, groupId, free = false) {\n    this._mediaLoader.releaseForGroup(url, groupId, free);\n    return this;\n  }\n\n  /**\n   * Unallocates the audio node reserved for sound.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number} soundId The sound id.\n   * @return {Engine}\n   */\n  releaseForSound(src, groupId, soundId) {\n    this._mediaLoader.releaseForSound(src, groupId, soundId);\n    return this;\n  }\n\n  /**\n   * Returns if there are free audio nodes available for a group.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The group id.\n   * @return {boolean}\n   */\n  hasFreeNodes(src, groupId) {\n    return this._mediaLoader.hasFreeNodes(src, groupId);\n  }\n\n  /**\n   * Destroys the audio node reserved for sound.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number} soundId The sound id.\n   */\n  destroyAllocatedAudio(src, groupId, soundId) {\n    this._mediaLoader.destroyAllocatedAudio(src, groupId, soundId);\n  }\n\n  /**\n   * Mutes the engine.\n   * @return {Engine}\n   */\n  mute() {\n    // If the engine is already muted return.\n    if (this._muted) {\n      return this;\n    }\n\n    // Set the value of gain node to 0.\n    this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n\n    // Set the muted property true.\n    this._muted = true;\n\n    // Fire the \"mute\" event.\n    this._fire(EngineEvents.Mute, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the engine.\n   * @return {Engine}\n   */\n  unmute() {\n    // If the engine is not muted return.\n    if (!this._muted) {\n      return this;\n    }\n\n    // Reset the gain node's value back to volume.\n    this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n\n    // Set the muted property to false.\n    this._muted = false;\n\n    // Fire the \"mute\" event.\n    this._fire(EngineEvents.Mute, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume for the audio engine that controls global volume for all sounds.\n   * @param {number} [vol] Should be within 0.0 to 1.0.\n   * @return {Engine|number}\n   */\n  volume(vol) {\n    // If no parameter is passed then return the current volume.\n    if (vol === undefined) {\n      return this._volume;\n    }\n\n    // If passed volume is not an acceptable value return.\n    if (typeof vol !== 'number' || vol < 0 || vol > 1.0) {\n      return this;\n    }\n\n    // Set the gain's value to the passed volume.\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : vol, this._context.currentTime);\n\n    // Set the volume to the property.\n    this._volume = vol;\n\n    // Fire the \"volume\" event.\n    this._fire(EngineEvents.Volume, this._volume);\n\n    return this;\n  }\n\n  /**\n   * Stops all the currently playing sounds.\n   * @return {Engine}\n   */\n  stop() {\n    // Stop all the sounds.\n    this._heap.sounds().forEach(sound => sound.stop());\n\n    // Fire the \"stop\" event.\n    this._fire(EngineEvents.Stop);\n\n    return this;\n  }\n\n  /**\n   * Stops all the playing sounds and suspends the audio context immediately.\n   * @return {Engine}\n   */\n  suspend() {\n    // If the context is resuming then suspend after resumed.\n    if (this._state === EngineState.Resuming) {\n      this._queue.add('after-resume', 'suspend', () => this.suspend());\n      return this;\n    }\n\n    // If the state is not ready return.\n    if (this._state !== EngineState.Ready) {\n      return this;\n    }\n\n    // Stop all the playing sounds.\n    this.stop();\n\n    // Set the state to suspending.\n    this._state = EngineState.Suspending;\n\n    // Suspend the Audio Context.\n    this._context.suspend().then(() => {\n      this._state = EngineState.Suspended;\n      this._queue.run('after-suspend');\n      this._fire(EngineEvents.Suspend);\n    });\n\n    return this;\n  }\n\n  /**\n   * Resumes the audio context from the suspended mode.\n   * @return {Engine}\n   */\n  resume() {\n    // If the context is suspending then resume after suspended.\n    if (this._state === EngineState.Suspending) {\n      this._queue.add('after-suspend', 'resume', () => this.resume());\n      return this;\n    }\n\n    if (this._state !== EngineState.Suspended) {\n      return this;\n    }\n\n    this._state = EngineState.Resuming;\n\n    this._context.resume().then(() => {\n      this._state = EngineState.Ready;\n      this._queue.run('after-resume');\n      this._fire(EngineEvents.Resume);\n    });\n\n    return this;\n  }\n\n  /**\n   * Shuts down the engine.\n   * @return {Engine}\n   */\n  terminate() {\n    if (this._state === EngineState.Done || this._state === EngineState.Destroying) {\n      return this;\n    }\n\n    const cleanUp = () => {\n      // Un-listen from user input events.\n      userInputEventNames.forEach(eventName => document.addEventListener(eventName, this._resumeAndRemoveListeners));\n\n      // Stop the timer.\n      this._intervalId && window.clearInterval(this._intervalId);\n      this._intervalId = null;\n\n      // Destroy the heap.\n      this._heap.destroy();\n      this._heap = null;\n\n      // Clear the cache and remove the loader.\n      if (this._bufferLoader) {\n        this._bufferLoader.dispose();\n        this._bufferLoader = null;\n      }\n\n      // Dispose the MediaLoader.\n      if (this._mediaLoader) {\n        this._mediaLoader.dispose();\n        this._mediaLoader = null;\n      }\n\n      this._context = null;\n      this._queue.clear();\n      this._queue = null;\n      this._state = EngineState.Done;\n\n      // Fire the \"done\" event.\n      this._fire(EngineEvents.Done);\n\n      emitter.clear(this._id);\n    };\n\n    // Close the context.\n    if (this._context) {\n      if (this._state === EngineState.Suspending) {\n        this._queue.remove('after-suspend');\n        this._queue.add('after-suspend', 'destroy', () => this.terminate());\n        return this;\n      } else if (this._state === EngineState.Resuming) {\n        this._queue.remove('after-resume');\n        this._queue.add('after-resume', 'destroy', () => this.terminate());\n        return this;\n      }\n\n      this._state = EngineState.Destroying;\n      this._context && this._context.close().then(() => cleanUp());\n    } else {\n      this._state = EngineState.Destroying;\n      cleanUp();\n    }\n\n    return this;\n  }\n\n  /**\n   * Subscribes to an event.\n   * @param {string} eventName Name of the event.\n   * @param {function} handler The event-handler function.\n   * @param {boolean} [once = false] Is it one-time subscription or not.\n   * @return {Engine}\n   */\n  on(eventName, handler, once = false) {\n    emitter.on(this._id, eventName, handler, once);\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event.\n   * @param {string} eventName The event name.\n   * @param {function} [handler] The handler function.\n   * @return {Engine}\n   */\n  off(eventName, handler) {\n    emitter.off(this._id, eventName, handler);\n    return this;\n  }\n\n  /**\n   * Returns the existing sound in heap or create a new one and return.\n   * @param {number|string} idOrUrl The sound id or audio url/base64 string.\n   * @param {number} [groupId] The group id.\n   * @param {object} [args] The sound creation arguments.\n   * @return {Sound}\n   */\n  sound(idOrUrl, groupId, args) {\n    if (typeof idOrUrl === 'number') {\n      return this._heap.sound(idOrUrl);\n    }\n\n    const sound = new Sound(args);\n    this._heap.add(idOrUrl, groupId, sound);\n    sound._gain().connect(this._gainNode);\n\n    return sound;\n  }\n\n  /**\n   * Removes the destroyed sound.\n   * @param {string} src The audio url.\n   * @param {number} groupId The group id.\n   * @param {number} soundId The sound id.\n   */\n  removeSound(src, groupId, soundId) {\n    this._heap.removeSound(src, groupId, soundId);\n  }\n\n  /**\n   * Returns the sounds belongs to a group or all the sounds from the heap.\n   * @param {number} [groupId] The group id.\n   * @return {Array<Sound>}\n   */\n  sounds(groupId) {\n    return this._heap.sounds(groupId);\n  }\n\n  /**\n   * Destroys the sounds belong to the passed group.\n   * @param {boolean} idle True to destroy only the idle sounds.\n   * @param {string} [src] The audio resource url.\n   * @param {number} [groupId] The group id.\n   * @return {Engine}\n   */\n  free(idle, src, groupId) {\n    this._heap.free(idle, src, groupId);\n    this._mediaLoader.cleanUp();\n    return this;\n  }\n\n  /**\n   * Returns whether the engine is currently muted or not.\n   * @return {boolean}\n   */\n  muted() {\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the engine.\n   * @return {EngineState}\n   */\n  state() {\n    return this._state;\n  }\n\n  /**\n   * Returns the created audio context.\n   * @return {AudioContext}\n   */\n  context() {\n    return this._context;\n  }\n\n  /**\n   * Returns the master gain node.\n   * @return {GainNode}\n   */\n  masterGain() {\n    return this._gainNode;\n  }\n\n  /**\n   * Returns true if Web Audio API is available.\n   * @return {boolean}\n   */\n  isAudioAvailable() {\n    return this._isAudioAvailable;\n  }\n\n  /**\n   * Returns the buffer loader.\n   * @return {BufferLoader}\n   */\n  bufferLoader() {\n    return this._bufferLoader;\n  }\n\n  /**\n   * Returns the HTML5 media loader.\n   * @return {MediaLoader}\n   */\n  mediaLoader() {\n    return this._mediaLoader;\n  }\n\n  /**\n   * Fires an event of engine.\n   * @param {string} eventName The event name.\n   * @param {...*} args The arguments that to be passed to handler.\n   * @return {Engine}\n   * @private\n   */\n  _fire(eventName, ...args) {\n    emitter.fire(this._id, eventName, ...args, this);\n    return this;\n  }\n\n  /**\n   * Resume the context and un-listen from user input events.\n   * @private\n   */\n  _resumeAndRemoveListeners() {\n    this.resume();\n    userInputEventNames.forEach(eventName => document.addEventListener(eventName, this._resumeAndRemoveListeners));\n  }\n}\n\nconst engine = new Engine();\nexport { engine as default, EngineState, EngineEvents, ErrorType };\n","/**\n * Enum to represent the download status of audio resource.\n * @enum {string}\n */\nconst DownloadStatus = {\n  Success: 'success',\n  Failure: 'error'\n};\n\nexport default DownloadStatus;\n","/**\n * Singleton global event emitter.\n * @class\n */\nclass Emitter {\n\n  /**\n   * Dictionary that maps the objects with their events and handlers.\n   * @type {object}\n   * @private\n   */\n  _objectsEventsHandlersMap = {};\n\n  /**\n   * Subscribes to an event of the passed object.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName Name of the event\n   * @param {function} handler The event-handler function\n   * @param {boolean} [once = false] Is it one-time subscription or not?\n   * @return {Emitter}\n   */\n  on(id, eventName, handler, once = false) {\n    if (!this._hasObject(id)) {\n      this._objectsEventsHandlersMap[id] = {};\n    }\n\n    const objEvents = this._objectsEventsHandlersMap[id];\n\n    if (!objEvents.hasOwnProperty(eventName)) {\n      objEvents[eventName] = [];\n    }\n\n    objEvents[eventName].push({\n      handler: handler,\n      once: once\n    });\n\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event of the passed object.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName The event name.\n   * @param {function} [handler] The handler function.\n   * @return {Emitter}\n   */\n  off(id, eventName, handler) {\n    if (!this._hasEvent(id, eventName)) {\n      return this;\n    }\n\n    const objEvents = this._objectsEventsHandlersMap[id];\n\n    if (!handler) {\n      objEvents[eventName] = [];\n    } else {\n      objEvents[eventName] = objEvents[eventName].filter(eventSubscriber => {\n        return eventSubscriber.handler !== handler;\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Fires an event of the object passing the source and other optional arguments.\n   * @param {number} id The unique id of the object.\n   * @param {string} eventName The event name\n   * @param {...*} args The arguments that to be passed to handler\n   * @return {Emitter}\n   */\n  fire(id, eventName, ...args) {\n    if (!this._hasEvent(id, eventName)) {\n      return this;\n    }\n\n    let eventSubscribers = this._objectsEventsHandlersMap[id][eventName];\n\n    for (let i = 0; i < eventSubscribers.length; i++) {\n      let eventSubscriber = eventSubscribers[i];\n\n      setTimeout(function (subscriber) {\n        const { handler, once } = subscriber;\n\n        handler(...args);\n\n        if (once) {\n          this.off(id, eventName, handler);\n        }\n      }.bind(this, eventSubscriber), 0);\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears the event handlers of the passed object.\n   * @param {number} [id] The unique id of the object.\n   * @return {Emitter}\n   */\n  clear(id) {\n    if (!id) {\n      this._objectsEventsHandlersMap = {};\n      return this;\n    }\n\n    if (this._hasObject(id)) {\n      delete this._objectsEventsHandlersMap[id];\n    }\n\n    return this;\n  }\n\n  /**\n   * Returns true if the object is already registered.\n   * @param {number} id The object id.\n   * @return {boolean}\n   * @private\n   */\n  _hasObject(id) {\n    return this._objectsEventsHandlersMap.hasOwnProperty(id);\n  }\n\n  /**\n   * Returns true if the passed object has an entry of the passed event.\n   * @param {number} id The object id.\n   * @param {string} eventName The event name.\n   * @return {boolean}\n   * @private\n   */\n  _hasEvent(id, eventName) {\n    return this._hasObject(id) && this._objectsEventsHandlersMap[id].hasOwnProperty(eventName);\n  }\n}\n\nexport default new Emitter();\n","/**\n * Stores queue of actions that has to be run before or after specific events.\n */\nclass Queue {\n\n  _eventActions = {};\n\n  /**\n   * Queues the passed action to the event.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @param {function} action The action function.\n   * @param {boolean} [removeAfterRun = true] Remove the action once it's run.\n   */\n  add(eventName, actionIdentifier, action, removeAfterRun = true) {\n    if (!this.hasEvent(eventName)) {\n      this._eventActions[eventName] = {};\n    }\n\n    this._eventActions[eventName][actionIdentifier] = { fn: action, removeAfterRun: removeAfterRun };\n  }\n\n  /**\n   * Returns true if there is a event exists for the passed name.\n   * @param {string} eventName The event name.\n   * @return {boolean}\n   */\n  hasEvent(eventName) {\n    return this._eventActions.hasOwnProperty(eventName);\n  }\n\n  /**\n   * Returns true if the passed action is already queued-up.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @return {boolean}\n   */\n  hasAction(eventName, actionIdentifier) {\n    if (!this.hasEvent(eventName)) {\n      return false;\n    }\n\n    return this._eventActions[eventName].hasOwnProperty(actionIdentifier);\n  }\n\n  /**\n   * Runs all the actions queued up for the passed event.\n   * @param {string} eventName The event name.\n   * @param {string} [actionIdentifier] The action identifier.\n   */\n  run(eventName, actionIdentifier) {\n    if (!this.hasEvent(eventName)) {\n      return;\n    }\n\n    if (typeof actionIdentifier !== 'undefined') {\n      if (!this.hasAction(eventName, actionIdentifier)) {\n        return;\n      }\n\n      this._run(eventName, actionIdentifier);\n\n      return;\n    }\n\n    Object.keys(this._eventActions[eventName]).forEach(action => this._run(eventName, action));\n  }\n\n  /**\n   * Removes the event or a queued action for the event.\n   * @param {string} eventName The event name.\n   * @param {string} [actionIdentifier] The action identifier.\n   */\n  remove(eventName, actionIdentifier) {\n    if (!this._eventActions.hasOwnProperty(eventName)) {\n      return;\n    }\n\n    if (!actionIdentifier) {\n      delete this._eventActions[eventName];\n      return;\n    }\n\n    delete this._eventActions[eventName][actionIdentifier];\n  }\n\n  /**\n   * Clears all the stored events and the queued-up actions.\n   */\n  clear() {\n    this._eventActions = {};\n  }\n\n  /**\n   * Runs a single action.\n   * @param {string} eventName The event name.\n   * @param {string} actionIdentifier The action identifier.\n   * @private\n   */\n  _run(eventName, actionIdentifier) {\n    const queued = this._eventActions[eventName][actionIdentifier];\n    queued.fn();\n    queued.removeAfterRun && this.remove(eventName, actionIdentifier);\n  }\n}\n\nexport default Queue;\n","import engine, { EngineEvents, EngineState, ErrorType } from './Engine';\nimport Queue from './Queue';\nimport utility from './Utility';\nimport emitter from './Emitter';\nimport DownloadStatus from './DownloadStatus';\n\n/**\n * Enum that represents the different states of a sound group (buzz).\n * @enum {string}\n */\nconst BuzzState = {\n  Ready: 'ready',\n  Destroyed: 'destroyed'\n};\n\n/**\n * Enum that represents the different events fired by a buzz.\n * @enum {string}\n */\nconst BuzzEvents = {\n  Load: 'load',\n  LoadProgress: 'loadprogress',\n  UnLoad: 'unload',\n  PlayStart: 'playstart',\n  PlayEnd: 'playend',\n  Pause: 'pause',\n  Stop: 'stop',\n  Volume: 'volume',\n  Mute: 'mute',\n  Seek: 'seek',\n  Rate: 'rate',\n  FadeStart: 'fadestart',\n  FadeEnd: 'fadeend',\n  FadeStop: 'fadestop',\n  Error: 'error',\n  Destroy: 'destroy'\n};\n\n/**\n * Enum that represents the different states occurs while loading a sound.\n * @enum {string}\n */\nconst LoadState = {\n  NotLoaded: 'notloaded',\n  Loading: 'loading',\n  Loaded: 'loaded',\n  AudioUnLoad: 'audio-unload'\n};\n\n/**\n * A wrapper class that simplifies dealing with group of sounds.\n */\nclass Buzz {\n\n  /**\n   * Unique id.\n   * @type {number}\n   * @private\n   */\n  _id = -1;\n\n  /**\n   * Represents the source of the sound. The source can be an url or base64 string.\n   * @type {*}\n   * @private\n   */\n  _src = null;\n\n  /**\n   * The formats of the passed audio sources.\n   * @type {Array<string>}\n   * @private\n   */\n  _format = [];\n\n  /**\n   * The sprite definition.\n   * @type {object}\n   * @private\n   */\n  _sprite = null;\n\n  /**\n   * The current volume of the sound. Should be from 0.0 to 1.0.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * The current rate of the playback. Should be from 0.5 to 5.\n   * @type {number}\n   * @private\n   */\n  _rate = 1;\n\n  /**\n   * True if the sound is currently muted.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * True if the sound should play repeatedly.\n   * @type {boolean}\n   * @private\n   */\n  _loop = false;\n\n  /**\n   * True to pre-loaded the sound on construction.\n   * @type {boolean}\n   * @private\n   */\n  _preload = false;\n\n  /**\n   * True to auto-play the sound on construction.\n   * @type {boolean}\n   * @private\n   */\n  _autoplay = false;\n\n  /**\n   * True to use HTML5 audio node.\n   * @type {boolean}\n   * @private\n   */\n  _stream = false;\n\n  /**\n   * Duration of the playback in seconds.\n   * @type {number}\n   * @private\n   */\n  _duration = 0;\n\n  /**\n   * The best compatible source in the audio sources passed.\n   * @type {string|null}\n   * @private\n   */\n  _compatibleSrc = null;\n\n  /**\n   * Represents the different states that occurs while loading the sound.\n   * @type {LoadState}\n   * @private\n   */\n  _loadState = LoadState.NotLoaded;\n\n  /**\n   * Represents the state of this group.\n   * @type {BuzzState}\n   * @private\n   */\n  _state = BuzzState.Ready;\n\n  /**\n   * The action queue.\n   * @type {Queue}\n   * @private\n   */\n  _queue = null;\n\n  /**\n   * The audio engine.\n   * @type {Engine}\n   * @private\n   */\n  _engine = null;\n\n  /**\n   * True if the group is currently fading.\n   * @type {boolean}\n   * @private\n   */\n  _fading = false;\n\n  /**\n   * The timer that runs function after the fading is complete.\n   * @type {number|null}\n   * @private\n   */\n  _fadeTimer = null;\n\n  _noOfLoadCalls = 0;\n\n  /**\n   * Initializes the internal properties.\n   * @param {string|Array<string>|object} args The input parameters of this sound group.\n   * @param {string} [args.id] The unique id of the sound.\n   * @param {string|string[]} args.src Single or array of audio urls/base64 strings.\n   * @param {number} [args.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [args.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [args.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [args.muted = false] True to be muted initially.\n   * @param {boolean} [args.preload = false] True to pre-load the sound after construction.\n   * @param {boolean} [args.autoplay = false] True to play automatically after construction.\n   * @param {boolean} [args.stream = false] True to use HTML5 audio node.\n   * @param {string|string[]} [args.format] The file format(s) of the passed audio source(s).\n   * @param {object} [args.sprite] The sprite definition.\n   * @param {function} [args.onload] Event-handler for the \"load\" event.\n   * @param {function} [args.onloadprogress] Event-handler for the \"loadprogress\" event (only for non-stream types).\n   * @param {function} [args.onunload] Event-handler for the \"unload\" event.\n   * @param {function} [args.onplaystart] Event-handler for the \"playstart\" event.\n   * @param {function} [args.onplayend] Event-handler for the \"playend\" event.\n   * @param {function} [args.onstop] Event-handler for the \"stop\" event.\n   * @param {function} [args.onpause] Event-handler for the \"pause\" event.\n   * @param {function} [args.onmute] Event-handler for the \"mute\" event.\n   * @param {function} [args.onvolume] Event-handler for the \"volume\" event.\n   * @param {function} [args.onrate] Event-handler for the \"rate\" event.\n   * @param {function} [args.onseek] Event-handler for the \"seek\" event.\n   * @param {function} [args.onerror] Event-handler for the \"error\" event.\n   * @param {function} [args.ondestroy] Event-handler for the \"destroy\" event.\n   * @constructor\n   */\n  constructor(args) {\n    this._onLoadProgress = this._onLoadProgress.bind(this);\n\n    // Setup the audio engine.\n    this._engine = engine;\n    this._engine.setup();\n    this._engine.on(EngineEvents.Resume, this._onEngineResume = this._onEngineResume.bind(this));\n\n    // If no audio is available throw error.\n    if (!this._engine.isAudioAvailable()) {\n      this._fire(BuzzEvents.Error, null, { type: ErrorType.NoAudio, error: 'Web Audio is un-available' });\n      return this;\n    }\n\n    if (typeof args === 'string') {\n      this._src = [args];\n    } else if (Array.isArray(args) && args.length) {\n      this._src = args;\n    } else if (typeof args === 'object') {\n      const {\n        id,\n        src,\n        format,\n        sprite,\n        volume,\n        rate,\n        muted,\n        loop,\n        autoplay,\n        stream,\n        preload,\n        onload,\n        onloadprogress,\n        onunload,\n        onplaystart,\n        onplayend,\n        onstop,\n        onpause,\n        onmute,\n        onvolume,\n        onrate,\n        onseek,\n        onerror,\n        ondestroy\n      } = args;\n\n      // Set the passed id or the random one.\n      this._id = typeof id === 'number' ? id : utility.id();\n\n      // Set the source.\n      if (typeof src === 'string') {\n        this._src = [src];\n      } else if (Array.isArray(src) && src.length) {\n        this._src = src;\n      }\n\n      // Set the format.\n      if (Array.isArray(format)) {\n        this._format = format;\n      } else if (typeof format === 'string' && format) {\n        this._format = [format];\n      }\n\n      // Set other properties.\n      typeof sprite === 'object' && (this._sprite = sprite);\n      typeof volume === 'number' && volume >= 0 && volume <= 1.0 && (this._volume = volume);\n      typeof rate === 'number' && rate >= 0.5 && rate <= 5 && (this._rate = rate);\n      typeof muted === 'boolean' && (this._muted = muted);\n      typeof loop === 'boolean' && (this._loop = loop);\n      typeof autoplay === 'boolean' && (this._autoplay = autoplay);\n      typeof stream === 'boolean' && (this._stream = stream);\n      typeof preload === 'boolean' && (this._preload = preload);\n\n      // Bind the passed event handlers to events.\n      typeof onload === 'function' && this.on(BuzzEvents.Load, onload);\n      typeof onloadprogress === 'function' && this.on(BuzzEvents.LoadProgress, onloadprogress);\n      typeof onunload === 'function' && this.on(BuzzEvents.UnLoad, onunload);\n      typeof onplaystart === 'function' && this.on(BuzzEvents.PlayStart, onplaystart);\n      typeof onplayend === 'function' && this.on(BuzzEvents.PlayEnd, onplayend);\n      typeof onstop === 'function' && this.on(BuzzEvents.Stop, onstop);\n      typeof onpause === 'function' && this.on(BuzzEvents.Pause, onpause);\n      typeof onmute === 'function' && this.on(BuzzEvents.Mute, onmute);\n      typeof onvolume === 'function' && this.on(BuzzEvents.Volume, onvolume);\n      typeof onrate === 'function' && this.on(BuzzEvents.Rate, onrate);\n      typeof onseek === 'function' && this.on(BuzzEvents.Seek, onseek);\n      typeof onerror === 'function' && this.on(BuzzEvents.Error, onerror);\n      typeof ondestroy === 'function' && this.on(BuzzEvents.Destroy, ondestroy);\n    }\n\n    // Throw error if source is not passed.\n    if (!this._src) {\n      throw new Error('You should pass the source for the audio.');\n    }\n\n    // Instantiate the dependencies.\n    this._queue = new Queue();\n\n    if (this._autoplay) {\n      this.play();\n    } else if (this._preload) {\n      this.load();\n    }\n  }\n\n  /**\n   * Loads the sound to the underlying audio object.\n   * @param {number} [soundId] The id of the sound to be loaded.\n   * @return {Buzz}\n   */\n  load(soundId) {\n    if (soundId) {\n      const sound = this.sound(soundId);\n      sound && sound.load();\n      return this;\n    }\n\n    if (!this._stream && (this.isLoaded() || this._loadState === LoadState.Loading)) {\n      return this;\n    }\n\n    this._loadState = LoadState.Loading;\n\n    this._noOfLoadCalls = this._noOfLoadCalls + 1;\n\n    const src = this._compatibleSrc || (this._compatibleSrc = this.getCompatibleSource());\n\n    // Load the audio source.\n    const load$ = this._stream ? this._engine.allocateForGroup(src, this._id) : this._engine.load(src, this._onLoadProgress);\n    load$.then(downloadResult => {\n\n      this._noOfLoadCalls > 0 && (this._noOfLoadCalls = this._noOfLoadCalls - 1);\n\n      if (this._stream && this._state === BuzzState.Destroyed) {\n        this._engine.releaseForGroup(this._compatibleSrc, this._id, this._loadState === LoadState.AudioUnLoad);\n        return;\n      } else if (this._state === BuzzState.Destroyed || this._loadState === LoadState.NotLoaded) {\n        return;\n      }\n\n      // If loading succeeded,\n      // i. Save the result.\n      // ii. Set the load state as loaded.\n      // iii. Fire the load event.\n      // iv. Run the methods that are queued to run after successful load.\n      if (downloadResult.status === DownloadStatus.Success) {\n        if (this._stream) {\n          this._duration = downloadResult.value.duration;\n        } else {\n          this._buffer = downloadResult.value;\n          this._duration = this._buffer.duration;\n        }\n\n        this._loadState = LoadState.Loaded;\n        this._fire(BuzzEvents.Load, null, downloadResult);\n        this._queue.run('after-load');\n        return;\n      }\n\n      this._onLoadFailure(downloadResult.error);\n    });\n\n    return this;\n  }\n\n  /**\n   * Returns the first compatible source based on the passed sources and the format.\n   * @return {string}\n   */\n  getCompatibleSource() {\n    // If the user has passed \"format\", check if it is supported or else retrieve the first supported source from the array.\n    return this._format.length ?\n      this._src[this._format.indexOf(utility.getSupportedFormat(this._format))] :\n      utility.getSupportedSource(this._src);\n  }\n\n  /**\n   * Plays the passed sound defined in the sprite or the sound that belongs to the passed id.\n   * @param {string|number} [soundOrId] The sound name defined in sprite or the sound id.\n   * @return {Buzz|number}\n   */\n  play(soundOrId) {\n    const isIdPassed = typeof soundOrId === 'number';\n\n    // If id is passed then get the sound from the engine and play it.\n    if (isIdPassed) {\n      const sound = this._engine.sound(soundOrId);\n      sound && this._play(sound);\n      return this;\n    }\n\n    const newSoundId = utility.id(),\n      playSound = () => {\n        const soundArgs = {\n          id: newSoundId,\n          buffer: this._buffer,\n          stream: this._stream,\n          audio: this._stream ? this._engine.allocateForSound(this._compatibleSrc, this._id, newSoundId) : null,\n          volume: this._volume,\n          rate: this._rate,\n          muted: this._muted,\n          loop: this._loop,\n          playEndCallback: () => this._fire(BuzzEvents.PlayEnd, newSoundId),\n          destroyCallback: () => {\n            // We supposed to call `releaseForSound` so we could re-use the HTML5 audio node but\n            // due to this open issue https://github.com/WebAudio/web-audio-api/issues/1202 we can't re-use it\n            // and so we are destroying it.\n            this._engine.destroyAllocatedAudio(this._compatibleSrc, newSoundId, this._id);\n            this._engine.removeSound(this._compatibleSrc, this._id, newSoundId);\n            this._fire(BuzzEvents.Destroy, newSoundId);\n            emitter.clear(newSoundId);\n          },\n          fadeEndCallback: () => this._fire(BuzzEvents.FadeEnd, newSoundId),\n          audioErrorCallback: (sound, err) => {\n            this._fire(BuzzEvents.Error, { type: ErrorType.LoadError, soundId: newSoundId, error: err });\n            this._engine.destroyAllocatedAudio(this._compatibleSrc, this._id, newSoundId);\n            sound.destroy();\n          },\n          loadCallback: () => {\n            this._fire(BuzzEvents.Load, newSoundId);\n          }\n        };\n\n        if (typeof soundOrId === 'string' && this._sprite && this._sprite.hasOwnProperty(soundOrId)) {\n          const positions = this._sprite[soundOrId];\n          soundArgs.startPos = positions[0];\n          soundArgs.endPos = positions[1];\n        }\n\n        const newSound = this._engine.sound(this._compatibleSrc, this._id, soundArgs);\n        this._play(newSound);\n      };\n\n    // If the sound is not yet loaded push an action to the queue to play the sound once it's loaded.\n    if (!this.isLoaded()) {\n      this._queue.add('after-load', `play-${newSoundId}`, () => playSound());\n      this.load();\n    } else {\n      playSound();\n    }\n\n    return newSoundId;\n  }\n\n  /**\n   * Pauses the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  pause(id) {\n    this._removePlayActions(id);\n    typeof id !== 'number' && this.fadeStop();\n    this._sounds(id).forEach(sound => sound.pause());\n    this._fire(BuzzEvents.Pause, id);\n\n    return this;\n  }\n\n  /**\n   * Stops the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  stop(id) {\n    this._removePlayActions(id);\n    typeof id !== 'number' && this.fadeStop();\n    this._sounds(id).forEach(sound => sound.stop());\n    this._fire(BuzzEvents.Stop, id);\n\n    return this;\n  }\n\n  /**\n   * Mutes the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  mute(id) {\n    const isGroup = typeof id !== 'number';\n    isGroup && this.fadeStop();\n    this._sounds(id).forEach(sound => sound.mute());\n    isGroup && (this._muted = true);\n\n    this._fire(BuzzEvents.Mute, id, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the sound belongs to the passed id or all the sounds belongs to this group.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  unmute(id) {\n    const isGroup = typeof id !== 'number';\n    isGroup && this.fadeStop();\n    this._sounds(id).forEach(sound => sound.unmute());\n    isGroup && (this._muted = false);\n\n    this._fire(BuzzEvents.Mute, id, this._muted);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume of the passed sound or the group.\n   * @param {number} [volume] Should be from 0.0 to 1.0.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|number}\n   */\n  volume(volume, id) {\n    const isGroup = typeof id !== 'number';\n\n    if (typeof volume === 'number' && volume >= 0 && volume <= 1.0) {\n      isGroup && this.fadeStop();\n      this._sounds(id).forEach(sound => sound.volume(volume));\n      typeof id !== 'number' && (this._volume = volume);\n      this._fire(BuzzEvents.Volume, id, this._volume);\n      return this;\n    }\n\n    if (!isGroup) {\n      const sound = this._engine.sound(id);\n      return sound ? sound.volume() : null;\n    }\n\n    return this._volume;\n  }\n\n  /**\n   * Fades the group's or passed sound's volume to the passed value in the passed duration.\n   * @param {number} to The destination volume.\n   * @param {number} duration The period of fade in seconds.\n   * @param {string} [type = linear] The fade type (linear or exponential).\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  fade(to, duration, type = 'linear', id) {\n    const isGroup = typeof id !== 'number';\n\n    if (isGroup && this._fading) {\n      return this;\n    }\n\n    this._fire(BuzzEvents.FadeStart, id);\n\n    this._sounds(id).forEach(sound => sound.fade(to, duration, type));\n\n    if (isGroup) {\n      this._fading = true;\n\n      this._fadeTimer = setTimeout(() => {\n        this.volume(to);\n\n        clearTimeout(this._fadeTimer);\n\n        this._fadeTimer = null;\n        this._fading = false;\n        this._fire(BuzzEvents.FadeEnd);\n      }, duration * 1000);\n    }\n\n    return this;\n  }\n\n  /**\n   * Stops the group's or passed sound's current running fade.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  fadeStop(id) {\n    const isGroup = typeof id !== 'number';\n\n    if (isGroup && !this._fading) {\n      return this;\n    }\n\n    this._sounds(id).forEach(sound => sound.fadeStop());\n\n    if (isGroup) {\n      if (this._fadeTimer) {\n        clearTimeout(this._fadeTimer);\n        this._fadeTimer = null;\n      }\n\n      this._fading = false;\n    }\n\n    this._fire(BuzzEvents.FadeStop, id);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the rate of the passed sound or the group.\n   * @param {number} [rate] Should be from 0.5 to 5.0.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|number}\n   */\n  rate(rate, id) {\n    if (typeof rate === 'number' && rate >= 0.5 && rate <= 5) {\n      this._sounds(id).forEach(sound => sound.rate(rate));\n      typeof id !== 'number' && (this._rate = rate);\n      this._fire(BuzzEvents.Rate, id, this._rate);\n      return this;\n    }\n\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.rate() : null;\n    }\n\n    return this._rate;\n  }\n\n  /**\n   * Gets/sets the current playback position of the sound.\n   * @param {number} id The sound id\n   * @param {number} [seek] The seek position.\n   * @return {Buzz|number}\n   */\n  seek(id, seek) {\n    if (!id) {\n      return this;\n    }\n\n    const sound = this.sound(id);\n\n    if (!sound) {\n      return this;\n    }\n\n    if (typeof seek === 'number') {\n      // If the audio source is not yet loaded push an item to the queue to seek after the sound is loaded\n      // and load the sound.\n      if (!this.isLoaded()) {\n        this._queue.add('after-load', `seek-${id}`, () => this.seek(id, seek));\n        this.load();\n        return this;\n      }\n\n      sound.seek(seek);\n      this._fire(BuzzEvents.Seek, id, seek);\n      return this;\n    }\n\n    return sound.seek();\n  }\n\n  /**\n   * Gets/sets the looping behavior of a sound or the group.\n   * @param {boolean} [loop] True to loop the sound.\n   * @param {number} [id] The sound id.\n   * @return {Buzz|boolean}\n   */\n  loop(loop, id) {\n    if (typeof loop === 'boolean') {\n      this._sounds(id).forEach(sound => sound.loop(loop));\n      typeof id !== 'number' && (this._loop = loop);\n      return this;\n    }\n\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.loop() : null;\n    }\n\n    return this._loop;\n  }\n\n  /**\n   * Returns true if the passed sound is playing.\n   * @param {number} id The sound id.\n   * @return {boolean}\n   */\n  playing(id) {\n    const sound = this._engine.sound(id);\n    return sound ? sound.isPlaying() : null;\n  }\n\n  /**\n   * Returns true if the passed sound is muted or the group is muted.\n   * @param {number} [id] The sound id.\n   * @return {boolean}\n   */\n  muted(id) {\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.muted() : null;\n    }\n\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the passed sound or the group.\n   * @param {number} [id] The sound id.\n   * @return {BuzzState|SoundState}\n   */\n  state(id) {\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.state() : null;\n    }\n\n    return this._state;\n  }\n\n  /**\n   * Returns the duration of the passed sound or the total duration of the sound.\n   * @param {number} [id] The sound id.\n   * @return {number}\n   */\n  duration(id) {\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? sound.duration() : null;\n    }\n\n    return this._duration;\n  }\n\n  /**\n   * Unloads the loaded audio buffer or free audio nodes.\n   * @return {Buzz}\n   */\n  unload() {\n    this._queue.remove('after-load');\n    this._stream && this._engine.releaseForGroup(this._compatibleSrc, this._id, true);\n    this._buffer = null;\n    this._stream && (this._duration = 0);\n    this._loadState = this._stream ? LoadState.AudioUnLoad : LoadState.NotLoaded;\n    this._noOfLoadCalls = 0;\n    return this;\n  }\n\n  /**\n   * Stops and destroys all the sounds belongs to this group and release other dependencies.\n   * @param {number} [soundId] The sound id.\n   */\n  destroy(soundId) {\n    if (soundId) {\n      const sound = this.sound(soundId);\n      sound && sound.destroy();\n      return;\n    }\n\n    if (this._state === BuzzState.Destroyed) {\n      return;\n    }\n\n    this.stop();\n    this._queue.clear();\n    this._engine.off(EngineEvents.Resume, this._onEngineResume);\n    this._engine.free(false, this._compatibleSrc, this._id);\n    this._engine.releaseForGroup(this._compatibleSrc, this._id);\n\n    this._buffer = null;\n    this._queue = null;\n    this._engine = null;\n    this._state = BuzzState.Destroyed;\n\n    this._fire(BuzzEvents.Destroy);\n\n    emitter.clear(this._id);\n  }\n\n  /**\n   * Makes the passed sound persistent that means it can't be auto-destroyed.\n   * @param {number} soundId The sound id.\n   */\n  persist(soundId) {\n    const sound = this.sound(soundId);\n    sound && sound.persist();\n  }\n\n  /**\n   * Makes the passed sound un-persistent that means it can be auto-destroyed.\n   * @param {number} soundId The sound id.\n   */\n  abandon(soundId) {\n    const sound = this.sound(soundId);\n    sound && sound.abandon();\n  }\n\n  /**\n   * Subscribes to an event for the sound or the group.\n   * @param {string} eventName The event name.\n   * @param {function} handler The event handler.\n   * @param {boolean} [once = false] True for one-time event handling.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  on(eventName, handler, once = false, id) {\n    emitter.on(id || this._id, eventName, handler, once);\n    return this;\n  }\n\n  /**\n   * Un-subscribes from an event for the sound or the group.\n   * @param {string} eventName The event name.\n   * @param {function} handler The event handler.\n   * @param {number} [id] The sound id.\n   * @return {Buzz}\n   */\n  off(eventName, handler, id) {\n    emitter.off(id || this._id, eventName, handler);\n    return this;\n  }\n\n  /**\n   * Returns the unique id of the sound.\n   * @return {number}\n   */\n  id() {\n    return this._id;\n  }\n\n  /**\n   * Returns the audio resource loading status.\n   * @return {LoadState}\n   */\n  loadState() {\n    return this._loadState;\n  }\n\n  /**\n   * Returns true if the audio source is loaded.\n   * @return {boolean}\n   */\n  isLoaded() {\n    return this._stream ? this._engine.hasFreeNodes(this._compatibleSrc, this._id) : this._loadState === LoadState.Loaded;\n  }\n\n  /**\n   * Returns the sound for the passed id.\n   * @param {number} id The sound id.\n   * @return {Sound}\n   */\n  sound(id) {\n    return this._engine.sound(id);\n  }\n\n  /**\n   * Returns true if the passed sound exists.\n   * @param {number} id The sound id.\n   * @return {boolean}\n   */\n  alive(id) {\n    return Boolean(this.sound(id));\n  }\n\n  /**\n   * Called on failure of loading audio source.\n   * @param {*} error The audio source load error.\n   * @private\n   */\n  _onLoadFailure(error) {\n    // Remove the queued actions from this class that are supposed to run after load.\n    this._noOfLoadCalls === 0 && this._queue.remove('after-load');\n\n    // Set the load state back to not loaded.\n    this._loadState = LoadState.NotLoaded;\n\n    // Fire the error event.\n    this._fire(BuzzEvents.Error, null, { type: ErrorType.LoadError, error: error });\n  }\n\n  /**\n   * The resource load progress handler.\n   * @param {object} evt The progress data.\n   * @private\n   */\n  _onLoadProgress(evt) {\n    this._fire(BuzzEvents.LoadProgress, null, evt.percentageDownloaded);\n  }\n\n  /**\n   * Whenever the engine resume run the actions queued for it.\n   * @private\n   */\n  _onEngineResume() {\n    this._queue.run('after-engine-resume');\n  }\n\n  /**\n   * Checks the engine state and plays the passed sound.\n   * @param {Sound} sound The sound.\n   * @private\n   */\n  _play(sound) {\n    if (this._engine.state() === EngineState.Destroying || this._engine.state() === EngineState.Done) {\n      this._fire(BuzzEvents.Error, null, { type: ErrorType.PlayError, error: 'The engine is stopping/stopped' });\n      return;\n    }\n\n    if (this._engine.state() === EngineState.NoAudio) {\n      this._fire(BuzzEvents.Error, null, { type: ErrorType.NoAudio, error: 'Web Audio is un-available' });\n      return;\n    }\n\n    const playAndFire = () => {\n      sound.play();\n      this._fire(BuzzEvents.PlayStart, sound.id());\n    };\n\n    if ([EngineState.Suspending, EngineState.Suspended, EngineState.Resuming].indexOf(this._engine.state()) > -1) {\n      this._queue.add('after-engine-resume', `sound-${sound.id()}`, () => playAndFire());\n      this._engine.state() !== EngineState.Resuming && this._engine.resume();\n      return;\n    }\n\n    playAndFire();\n  }\n\n  /**\n   * Remove the play actions queued from the queue.\n   * @param {number} [id] The sound id.\n   * @private\n   */\n  _removePlayActions(id) {\n    this._queue.remove('after-load', id ? `play-${id}` : null);\n    this._queue.remove('after-engine-resume', id ? `sound-${id}` : null);\n  }\n\n  /**\n   * Returns the sound for the passed id or all the sounds belong to this group.\n   * @param {number} [id] The sound id.\n   * @return {Array<Sound>}\n   * @private\n   */\n  _sounds(id) {\n    if (typeof id === 'number') {\n      const sound = this._engine.sound(id);\n      return sound ? [sound] : [];\n    }\n\n    return this._engine.sounds(this._id);\n  }\n\n  /**\n   * Fires an event of group or sound.\n   * @param {string} eventName The event name.\n   * @param {number} [id] The sound id.\n   * @param {...*} args The arguments that to be passed to handler.\n   * @return {Buzz}\n   * @private\n   */\n  _fire(eventName, id, ...args) {\n    if (id) {\n      emitter.fire(id, eventName, ...args, this.sound(id), this);\n      emitter.fire(this._id, eventName, ...args, this.sound(id), this);\n    } else {\n      emitter.fire(this._id, eventName, ...args, this);\n    }\n\n    return this;\n  }\n}\n\nconst $buzz = args => new Buzz(args);\n[\n  'setup',\n  'load',\n  'loadMedia',\n  'unload',\n  'unloadMedia',\n  'mute',\n  'unmute',\n  'volume',\n  'stop',\n  'suspend',\n  'resume',\n  'terminate',\n  'muted',\n  'state',\n  'context',\n  'masterGain',\n  'isAudioAvailable',\n  'bufferLoader',\n  'mediaLoader',\n  'on',\n  'off'\n].forEach(method => {\n  $buzz[method] = function () {\n    const result = engine[method](...arguments);\n    return result === engine ? $buzz : result;\n  };\n});\n\nmodule.exports = $buzz;\n","import utility from './Utility';\nimport DownloadResult from './DownloadResult';\n\n/**\n * Loads the audio sources into audio buffers and returns them.\n * The loaded buffers are cached.\n * @class\n */\nclass BufferLoader {\n\n  /**\n   * AudioContext.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * In-memory audio buffer cache store.\n   * @type {object}\n   * @private\n   */\n  _bufferCache = {};\n\n  /**\n   * Dictionary to store the current progress calls and their callbacks.\n   * @type {object}\n   * @private\n   */\n  _progressCallsAndCallbacks = {};\n\n  /**\n   * True if the loader is disposed.\n   * @type {boolean}\n   * @private\n   */\n  _disposed = false;\n\n  /**\n   * Create the cache.\n   * @param {AudioContext} context The Audio Context\n   */\n  constructor(context) {\n    this._context = context;\n  }\n\n  /**\n   * Loads single or multiple audio resources into audio buffers.\n   * @param {string|string[]} urls Single or array of audio urls.\n   * @param {function} [progressCallback] The callback that is called to intimate the percentage downloaded.\n   * @return {Promise<DownloadResult|Array<DownloadResult>>}\n   */\n  load(urls, progressCallback) {\n    if (typeof urls === 'string') {\n      return this._load(urls, progressCallback);\n    }\n\n    return Promise.all(urls.map(url => this._load(url, progressCallback)));\n  }\n\n  /**\n   * Removes the cached audio buffers.\n   * @param {string|string[]} [urls] Single or array of audio urls\n   */\n  unload(urls) {\n    if (typeof urls === 'string') {\n      this._unload(urls);\n      return;\n    }\n\n    if (Array.isArray(urls)) {\n      urls.forEach(url => this._unload(url), this);\n      return;\n    }\n\n    this._bufferCache = {};\n  }\n\n  /**\n   * Dispose the loader.\n   */\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n\n    this.unload();\n    this._bufferCache = null;\n    this._progressCallsAndCallbacks = null;\n    this._context = null;\n    this._disposed = true;\n  }\n\n  /**\n   * Loads a single audio resource into audio buffer and cache result if the download is succeeded.\n   * @param {string} url The Audio url.\n   * @param {function} [progressCallback] The callback that is called to intimate the percentage downloaded.\n   * @return {Promise<DownloadResult>}\n   * @private\n   */\n  _load(url, progressCallback) {\n    return new Promise(resolve => {\n      if (this._bufferCache.hasOwnProperty(url)) {\n        resolve(new DownloadResult(url, this._bufferCache[url]));\n        return;\n      }\n\n      if (this._progressCallsAndCallbacks.hasOwnProperty(url)) {\n        this._progressCallsAndCallbacks[url].push(resolve);\n        return;\n      }\n\n      this._progressCallsAndCallbacks[url] = [];\n      this._progressCallsAndCallbacks[url].push(resolve);\n\n      const reject = err => {\n        if (this._disposed) {\n          return;\n        }\n\n        this._progressCallsAndCallbacks[url].forEach(r => r(new DownloadResult(url, null, err)));\n        delete this._progressCallsAndCallbacks[url];\n      };\n\n      const decodeAudioData = arrayBuffer => {\n        if (this._disposed) {\n          return;\n        }\n\n        this._context.decodeAudioData(arrayBuffer, buffer => {\n          this._bufferCache[url] = buffer;\n          this._progressCallsAndCallbacks[url].forEach(r => r(new DownloadResult(url, buffer)));\n          delete this._progressCallsAndCallbacks[url];\n        }, reject);\n      };\n\n      if (utility.isBase64(url)) {\n        const data = atob(url.split(',')[1]);\n        const dataView = new Uint8Array(data.length); // eslint-disable-line no-undef\n\n        for (let i = 0; i < data.length; i++) {\n          dataView[i] = data.charCodeAt(i);\n        }\n\n        decodeAudioData(dataView.buffer);\n        return;\n      }\n\n      const req = new XMLHttpRequest();\n      req.open('GET', url, true);\n      req.responseType = 'arraybuffer';\n\n      req.addEventListener('load', () => decodeAudioData(req.response), false);\n\n      if (progressCallback) {\n        req.addEventListener('progress', (evt) => {\n          if (!evt.lengthComputable) {\n            progressCallback({ url: url, percentageDownloaded: 0 });\n          }\n\n          const percentageDownloaded = Math.round((evt.loaded / evt.total) * 100);\n          progressCallback({ url: url, percentageDownloaded: percentageDownloaded });\n        });\n      }\n\n      req.addEventListener('error', reject, false);\n      req.send();\n    });\n  }\n\n  /**\n   * Removes the single cached audio buffer.\n   * @param {string} url Audio url\n   * @private\n   */\n  _unload(url) {\n    delete this._bufferCache[url];\n  }\n}\n\nexport default BufferLoader;\n","import Html5AudioPool from './Html5AudioPool';\nimport DownloadResult from './DownloadResult';\n\n/**\n * Loads the HTML5 audio nodes and returns them.\n * @class\n */\nclass MediaLoader {\n\n  /**\n   * HTML5 audio pool.\n   * @type {Html5AudioPool}\n   * @private\n   */\n  _audioPool = null;\n\n  /**\n   * Store the array of audio elements that are currently in buffering state.\n   * @type {Array}\n   * @private\n   */\n  _bufferingAudios = [];\n\n  /**\n   * True if the loader is disposed.\n   * @type {boolean}\n   * @private\n   */\n  _disposed = false;\n\n  /**\n   * Creates the audio pool.\n   * @param {number} maxNodesPerSource Maximum number of audio nodes allowed for a url.\n   * @param {Heap} heap The sounds store.\n   */\n  constructor(maxNodesPerSource, heap) {\n    this._audioPool = new Html5AudioPool(maxNodesPerSource, heap);\n  }\n\n  /**\n   * Preloads the HTML5 audio nodes with audio and return them.\n   * @param {string|string[]} urls Single or array of audio file urls.\n   * @return {Promise<DownloadResult|Array<DownloadResult>>}\n   */\n  load(urls) {\n    console.log(typeof urls);\n    if (typeof urls === 'string') {\n      return this._load(urls);\n    }\n\n    return Promise.all(urls.map(url => this._load(url)));\n  }\n\n  /**\n   * Loads audio node for group.\n   * @param {string} url The audio file url.\n   * @param {number} groupId The group id.\n   * @return {Promise<DownloadResult>}\n   */\n  allocateForGroup(url, groupId) {\n    return this._load(url, groupId);\n  }\n\n  /**\n   * Allocates an audio node for sound and returns it.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number} soundId The sound id.\n   * @return {Audio}\n   */\n  allocateForSound(src, groupId, soundId) {\n    return this._audioPool.allocateForSound(src, groupId, soundId);\n  }\n\n  /**\n   * Releases the allocated audio node(s).\n   * @param {string|string[]} [urls] Single or array of audio file urls.\n   */\n  unload(urls) {\n    const removeAudioObjOfUrl = url => {\n      const audioObj = this._bufferingAudios.find(a => a.url === url);\n      audioObj && this._cleanUp(audioObj);\n    };\n\n    if (!urls) {\n      this._bufferingAudios.forEach(audioObj => this._cleanUp(audioObj));\n    } else if (typeof urls === 'string') {\n      removeAudioObjOfUrl(urls);\n    } else if (Array.isArray(urls) && urls.length) {\n      urls.forEach(url => removeAudioObjOfUrl(url));\n    }\n\n    urls.forEach(url => this._audioPool.releaseForSource(url));\n  }\n\n  /**\n   * Releases the allocated audio node for the group.\n   * @param {string} url The audio file url.\n   * @param {number} groupId The group id.\n   * @param {boolean} [free = false] Pass true to release only free audio nodes.\n   */\n  releaseForGroup(url, groupId, free = false) {\n    this._bufferingAudios\n      .filter(a => a.groupId === groupId)\n      .forEach(a => this._cleanUp(a));\n\n    this._audioPool.releaseForGroup(url, groupId, free);\n  }\n\n  /**\n   * Unallocates the audio node reserved for sound.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number} soundId The sound id.\n   */\n  releaseForSound(src, groupId, soundId) {\n    this._audioPool.releaseForSound(src, groupId, soundId);\n  }\n\n  /**\n   * Returns if there are free audio nodes available for a group.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The group id.\n   * @return {boolean}\n   */\n  hasFreeNodes(src, groupId) {\n    return this._audioPool.hasFreeNodes(src, groupId);\n  }\n\n  /**\n   * Destroys the audio node reserved for sound.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The buzz id.\n   * @param {number} soundId The sound id.\n   */\n  destroyAllocatedAudio(src, groupId, soundId) {\n    this._audioPool.destroyAllocatedAudio(src, groupId, soundId);\n  }\n\n  /**\n   * Acquires the unallocated audio nodes and removes the excess ones.\n   */\n  cleanUp() {\n    this._audioPool.cleanUp();\n  }\n\n  /**\n   * Clear the event handlers of buffering audio elements and dispose the pool.\n   */\n  dispose() {\n    if (this._disposed) {\n      return;\n    }\n\n    [...this._bufferingAudios].forEach(audioObj => this._cleanUp(audioObj));\n    this._bufferingAudios = null;\n    this._audioPool.dispose();\n    this._audioPool = null;\n    this._disposed = true;\n  }\n\n  /**\n   * Preload the HTML5 audio element with the passed audio file and allocate it to the passed sound (if any).\n   * @param {string} url The audio file url.\n   * @param {number} [groupId] The buzz id.\n   * @return {Promise}\n   * @private\n   */\n  _load(url, groupId) {\n    return new Promise(resolve => {\n      const audio = groupId ? this._audioPool.allocateForGroup(url, groupId) : this._audioPool.allocateForSource(url);\n\n      const onCanPlayThrough = () => {\n        if (this._disposed) {\n          return;\n        }\n\n        const audioObj = this._bufferingAudios.find(obj => obj.audio === audio);\n        audioObj && this._cleanUp(audioObj);\n        resolve(new DownloadResult(url, audio));\n      };\n\n      const onError = (err) => {\n        if (this._disposed) {\n          return;\n        }\n\n        const audioObj = this._bufferingAudios.find(obj => obj.audio === audio);\n        audioObj && this._cleanUp(audioObj);\n        this._audioPool.destroyAllocatedAudio(url, audio, groupId);\n        resolve(new DownloadResult(url, null, err));\n      };\n\n      audio.addEventListener('canplaythrough', onCanPlayThrough);\n      audio.addEventListener('error', onError);\n\n      this._bufferingAudios.push({\n        url: url,\n        groupId: groupId,\n        audio: audio,\n        canplaythrough: onCanPlayThrough,\n        error: onError\n      });\n\n      if (!audio.src) { // new audio element?\n        audio.src = url;\n        audio.load();\n        return;\n      }\n\n      audio.currentTime = 0;\n\n      if (audio.readyState >= 3) {\n        onCanPlayThrough();\n      }\n    });\n  }\n\n  /**\n   * Removes the event-handlers from the audio element.\n   * @param {object} audioObj The buffering audio object.\n   * @private\n   */\n  _cleanUp(audioObj) {\n    ['canplaythrough', 'error'].forEach(evt => audioObj.audio.removeEventListener(evt, audioObj[audioObj]));\n    this._bufferingAudios.splice(this._bufferingAudios.indexOf(audioObj), 1);\n  }\n}\n\nexport default MediaLoader;\n","import utility from './Utility';\n\n/**\n * Manages the pool of HTML5 audio nodes.\n * @class\n */\nclass Html5AudioPool {\n\n  /**\n   * Maximum number of audio nodes allowed for a url.\n   * @type {number}\n   * @private\n   */\n  _maxNodesPerSource = 100;\n\n  /**\n   * The sounds store.\n   * @type {Heap}\n   * @private\n   */\n  _heap = null;\n\n  /**\n   * Created audio nodes for each resource.\n   * @type {object}\n   * @private\n   */\n  _resourceNodesMap = {};\n\n  /**\n   * True if the heap is cleaned manually.\n   * @type {boolean}\n   * @private\n   */\n  _heapCleaned = false;\n\n  /**\n   * Constructor\n   * @param {number} maxNodesPerSource Maximum number of audio nodes allowed for a url.\n   * @param {Heap} heap The sounds store.\n   */\n  constructor(maxNodesPerSource, heap) {\n    this._maxNodesPerSource = maxNodesPerSource;\n    this._heap = heap;\n  }\n\n  /**\n   * Allocates an audio node for particular source.\n   * @param {string} src The audio url.\n   * @return {Audio}\n   */\n  allocateForSource(src) {\n    this._createSrc(src);\n    this._checkMaxNodesForSrc(src);\n\n    const nodes = this._resourceNodesMap[src],\n      { unallocated } = nodes;\n\n    const audio = new Audio();\n    unallocated.push(audio);\n\n    return audio;\n  }\n\n  /**\n   * Allocates a HTML5 audio node to a particular resource and group.\n   * @param {string} src The audio url.\n   * @param {number} [groupId] The buzz group id.\n   * @return {Audio}\n   */\n  allocateForGroup(src, groupId) {\n    this._createGroup(src, groupId);\n    this._checkMaxNodesForSrc(src);\n\n    const nodes = this._resourceNodesMap[src],\n      { unallocated, allocated } = nodes,\n      audio = unallocated.length ? unallocated.shift() : new Audio(),\n      groupSounds = allocated[groupId];\n\n    groupSounds.push({\n      audio: audio,\n      soundId: null\n    });\n\n    return audio;\n  }\n\n  /**\n   * Allocates the pre-loaded HTML5 audio node to a sound.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The group id.\n   * @param {number} soundId The sound id.\n   * @return {Audio}\n   */\n  allocateForSound(src, groupId, soundId) {\n    this._createGroup(src, groupId);\n\n    const nodes = this._resourceNodesMap[src],\n      { allocated } = nodes,\n      notAllocatedAudioObj = allocated[groupId].find(x => x.soundId === null);\n\n    if (!notAllocatedAudioObj) {\n      throw new Error(`No free audio nodes available in the group ${groupId}`);\n    }\n\n    notAllocatedAudioObj.soundId = soundId;\n\n    return notAllocatedAudioObj.audio;\n  }\n\n  /**\n   * Releases all the audio nodes created for a resource.\n   * @param {string} src The audio url.\n   */\n  releaseForSource(src) {\n    const nodes = this._resourceNodesMap[src],\n      { unallocated, allocated } = nodes;\n\n    unallocated.forEach(x => this._destroyNode(x));\n\n    Object.keys(allocated).forEach(groupId => {\n      allocated[groupId].forEach(x => this._destroyNode(x.audio));\n      delete allocated[groupId];\n    });\n\n    delete this._resourceNodesMap[src];\n  }\n\n  /**\n   * Releases all the audio nodes allocated for a group.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The group id.\n   * @param {boolean} [free = false] Pass true to release only free audio nodes.\n   */\n  releaseForGroup(src, groupId, free = false) {\n    const nodes = this._resourceNodesMap[src],\n      { allocated } = nodes;\n\n    if (!free) {\n      allocated[groupId].map(x => x.audio).forEach(node => this._destroyNode(node));\n      delete allocated[groupId];\n      return;\n    }\n\n    const audioNodes = allocated[groupId].filter(x => x.soundId === null).map(x => x.audio);\n    allocated[groupId] = allocated[groupId].filter(x => x.soundId !== null);\n    // nodes.unallocated = [...unallocated, ...audioNodes]; https://github.com/WebAudio/web-audio-api/issues/1202\n    audioNodes.forEach(node => this._destroyNode(node));\n  }\n\n  /**\n   * Release the audio element that is allocated for the sound.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The group id.\n   * @param {number} soundId The sound id.\n   */\n  releaseForSound(src, groupId, soundId) {\n    const nodes = this._resourceNodesMap[src],\n      { unallocated, allocated } = nodes;\n\n    const allocatedAudioObj = allocated[groupId].find(x => x.soundId === soundId);\n\n    if (!allocatedAudioObj) {\n      return;\n    }\n\n    allocated[groupId] = allocated[groupId].filter(x => x.soundId !== soundId);\n    nodes.unallocated = [...unallocated, allocatedAudioObj.audio];\n  }\n\n  /**\n   * Returns if there are free audio nodes available for a group.\n   * @param {string} src The audio file url.\n   * @param {number} groupId The group id.\n   * @return {boolean}\n   */\n  hasFreeNodes(src, groupId) {\n    if (!this._resourceNodesMap.hasOwnProperty(src)) {\n      return false;\n    }\n\n    const nodes = this._resourceNodesMap[src],\n      { allocated } = nodes;\n\n    const unallocatedObjects = allocated[groupId].filter(x => x.soundId === null);\n    return unallocatedObjects.length > 0;\n  }\n\n  /**\n   * Destroys the audio node reserved for sound.\n   * @param {string} src The audio file url.\n   * @param {number|Audio} soundIdOrAudio The sound id.\n   * @param {number} groupId The buzz id.\n   */\n  destroyAllocatedAudio(src, soundIdOrAudio, groupId) {\n    const nodes = this._resourceNodesMap[src],\n      { allocated, unallocated } = nodes;\n\n    if (soundIdOrAudio instanceof Audio) {\n      this._destroyNode(soundIdOrAudio);\n\n      if (groupId) {\n        allocated[groupId] = allocated[groupId].filter(x => x.audio !== soundIdOrAudio);\n      } else {\n        nodes.unallocated = unallocated.filter(x => x !== soundIdOrAudio);\n      }\n    } else {\n      const allocatedAudioObj = allocated[groupId].find(x => x.soundId === soundIdOrAudio);\n      this._destroyNode(allocatedAudioObj.audio);\n      allocated[groupId] = allocated[groupId].filter(x => x.soundId !== soundIdOrAudio);\n    }\n\n    groupId && !allocated[groupId].length && delete allocated[groupId];\n    !unallocated.length && !Object.keys(allocated).length && delete this._resourceNodesMap[src];\n  }\n\n  /**\n   * Acquires the unallocated audio nodes and removes the excess ones.\n   */\n  cleanUp() {\n    Object.keys(this._resourceNodesMap).forEach(src => {\n      const nodes = this._resourceNodesMap[src],\n        { unallocated, allocated } = nodes;\n\n      let audioNodes = [];\n\n      Object.keys(allocated).forEach(groupId => {\n        audioNodes = [...audioNodes, ...allocated[groupId].filter(x => x.soundId === null).map(x => x.audio)];\n        allocated[groupId] = allocated[groupId].filter(x => x.soundId !== null);\n      });\n\n      nodes.unallocated = [...unallocated, ...audioNodes].slice(0, this._maxNodesPerSource);\n    });\n  }\n\n  /**\n   * Releases all the audio nodes.\n   */\n  dispose() {\n    Object.keys(this._resourceNodesMap).forEach(src => this.releaseForSource(src));\n    this._heap = null;\n  }\n\n  /**\n   * Creates an entry for the passed source in object if not exists.\n   * @param {string} src The audio file.\n   * @private\n   */\n  _createSrc(src) {\n    if (this._resourceNodesMap.hasOwnProperty(src)) {\n      return;\n    }\n\n    this._resourceNodesMap[src] = {\n      unallocated: [],\n      allocated: {}\n    };\n  }\n\n  /**\n   * Creates an entry for the passed source and group if not exists.\n   * @param {string} src The audio file.\n   * @param {number} groupId The group id.\n   * @private\n   */\n  _createGroup(src, groupId) {\n    this._createSrc(src);\n\n    const nodes = this._resourceNodesMap[src],\n      { allocated } = nodes;\n\n    if (allocated.hasOwnProperty(groupId)) {\n      return;\n    }\n\n    allocated[groupId] = [];\n  }\n\n  /**\n   * Chekcks and throws error if max audio nodes reached for the passed resource.\n   * @param {string} src The source url.\n   * @private\n   */\n  _checkMaxNodesForSrc(src) {\n    if (!this._resourceNodesMap.hasOwnProperty(src)) {\n      return;\n    }\n\n    const nodes = this._resourceNodesMap[src],\n      { unallocated, allocated } = nodes;\n\n    let totalAllocatedLength = 0;\n\n    Object.keys(allocated).forEach(groupId => {\n      totalAllocatedLength = totalAllocatedLength + allocated[groupId].length;\n    });\n\n    if (unallocated.length + totalAllocatedLength < this._maxNodesPerSource) {\n      return;\n    }\n\n    if (!this._heapCleaned) {\n      this._heap.free(src);\n      this._heapCleaned = true;\n      this._checkMaxNodesForSrc(src);\n    }\n\n    this._heapCleaned = false;\n\n    throw new Error(`Maximum nodes reached for resource ${src}`);\n  }\n\n  /**\n   * Destroys the passed audio node.\n   * @param {Audio} audio The HTML5 audio element.\n   * @private\n   */\n  _destroyNode(audio) {\n    audio.pause();\n    utility.isIE() && (audio.src = 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');\n    audio.onerror = null;\n    audio.onend = null;\n    audio.canplaythrough = null;\n  }\n}\n\nexport default Html5AudioPool;\n","/**\n * Represents a heap item.\n */\nclass HeapItem {\n\n  /**\n   * The sound object.\n   * @type {Sound}\n   */\n  sound = null;\n\n  /**\n   * The group id.\n   * @type {number|null}\n   */\n  groupId = null;\n\n  /**\n   * Set the group id and sound.\n   * @param {number} groupId The group id.\n   * @param {Sound} sound The sound instance.\n   */\n  constructor(groupId, sound) {\n    this.groupId = groupId;\n    this.sound = sound;\n  }\n}\n\n/**\n * Represents a collection of sounds belong to an audio resource.\n */\nclass HeapItemCollection {\n\n  /**\n   * The audio source url.\n   * @type {string|null}\n   */\n  _url = null;\n\n  /**\n   * The collection of sound objects.\n   * @type {object}\n   */\n  items = {};\n\n  /**\n   * The inactive time of sound.\n   * @type {number}\n   * @private\n   */\n  _inactiveTime = 0;\n\n  /**\n   * Initialize stuff.\n   * @param {string} url The audio url.\n   * @param {number} inactiveTime The inactive time of sound.\n   */\n  constructor(url, inactiveTime) {\n    this._url = url;\n    this._inactiveTime = inactiveTime;\n    this.free = this.free.bind(this);\n  }\n\n  /**\n   * Adds a new sound item to the collection.\n   * @param {number} groupId The group id.\n   * @param {Sound} sound The sound instance.\n   */\n  add(groupId, sound) {\n    const soundId = sound.id().toString();\n\n    if (this.items.hasOwnProperty(soundId)) {\n      return;\n    }\n\n    this.items[soundId] = new HeapItem(groupId, sound);\n  }\n\n  /**\n   * Removes the sounds.\n   * @param {boolean} [idle = true] True to destroy only the idle sounds.\n   * @param {number} [groupId] The group id.\n   */\n  free(idle = true, groupId) {\n    const now = new Date();\n\n    Object.values(this.items).forEach(item => {\n      const { sound, soundGroupId } = item;\n      const inactiveDurationInSeconds = (now - sound.lastPlayed()) / 1000;\n\n      if (idle && (sound.isPersistent() ||\n        sound.isPlaying() ||\n        sound.isPaused() ||\n        inactiveDurationInSeconds < this._inactiveTime * 60)) {\n        return;\n      }\n\n      if (!Boolean(groupId) || soundGroupId === groupId) {\n        sound.destroy();\n        delete this.items[sound.id()];\n      }\n    });\n  }\n\n  /**\n   * Returns the sounds belong to the group or all the sounds in the collection.\n   * @param {number} [groupId] The group id.\n   * @return {Array<HeapItem>}\n   */\n  sounds(groupId) {\n    const itemsArray = Object.values(this.items);\n    const items = groupId ? itemsArray.filter(item => item.groupId === groupId) : itemsArray;\n    return items.map(item => item.sound);\n  }\n\n  /**\n   * Destroys all the sounds.\n   */\n  destroy() {\n    Object.values(this.items).forEach(item => item.sound.destroy());\n    this.items = {};\n  }\n}\n\n/**\n * Stores all the created sounds.\n */\nclass Heap {\n\n  /**\n   * The inactive time of sound.\n   * @type {number}\n   * @private\n   */\n  _inactiveTime = 0;\n\n  /**\n   * The sound collections.\n   * @type {object}\n   * @private\n   */\n  _collections = {};\n\n  /**\n   * Initialize stuff.\n   * @param {number} inactiveTime The inactive time of sound in minutes.\n   */\n  constructor(inactiveTime) {\n    this._inactiveTime = inactiveTime;\n    this.free = this.free.bind(this);\n  }\n\n  /**\n   * Adds a new sound to the respective collection.\n   * @param {string} url The audio source url or base64 string.\n   * @param {number} groupId The group id.\n   * @param {Sound} sound The sound instance.\n   */\n  add(url, groupId, sound) {\n    if (!this._collections.hasOwnProperty(url)) {\n      this._collections[url] = new HeapItemCollection(url, this._inactiveTime);\n    }\n\n    this._collections[url].add(groupId, sound);\n  }\n\n  /**\n   * Returns the sound based on the id.\n   * @param {number} id The sound id.\n   * @return {Sound}\n   */\n  sound(id) {\n    return this.sounds().find(sound => sound.id() === id);\n  }\n\n  /**\n   * Returns the sounds belongs to a particular group or all of them.\n   * @param {number} [groupId] The group id.\n   * @return {Array}\n   */\n  sounds(groupId) {\n    const sounds = [];\n    Object.values(this._collections).forEach(col => sounds.push(...col.sounds(groupId)));\n    return sounds;\n  }\n\n  /**\n   * Removes sounds from the collections.\n   * @param {boolean} [idle = true] True to destroy only the idle sounds.\n   * @param {string} [src] The audio resource url.\n   * @param {number} [groupId] The group id.\n   */\n  free(idle = true, src, groupId) {\n    if (src) {\n      this._collections[src].free(idle, groupId);\n      return;\n    }\n\n    Object.values(this._collections).forEach(col => col.free(idle, groupId));\n  }\n\n  /**\n   * Removes the destroyed sound.\n   * @param {string} src The audio url.\n   * @param {number} groupId The group id.\n   * @param {number} soundId The sound id.\n   */\n  removeSound(src, groupId, soundId) {\n    delete this._collections[src].items[soundId];\n  }\n\n  /**\n   * Destroys all the sounds.\n   */\n  destroy() {\n    Object.values(this._collections).forEach(col => col.destroy());\n    this._collections = {};\n  }\n}\n\nexport default Heap;\n","import engine         from './Engine';\nimport utility        from './Utility';\nimport workerTimer    from './WorkerTimer';\nimport DownloadResult from './DownloadResult';\n\n/**\n * Enum that represents the different states of a sound.\n * @enum {string}\n */\nconst SoundState = {\n  Ready: 'ready',\n  Playing: 'playing',\n  Paused: 'paused',\n  Destroyed: 'destroyed'\n};\n\n/**\n * Represents a sound created using Web Audio API.\n * @class\n */\nclass Sound {\n\n  /**\n   * Unique id.\n   * @type {number}\n   * @private\n   */\n  _id = -1;\n\n  /**\n   * The current volume of the sound. Should be from 0.0 to 1.0.\n   * @type {number}\n   * @private\n   */\n  _volume = 1.0;\n\n  /**\n   * The current playback speed. Should be from 0.5 to 5.\n   * @type {number}\n   * @private\n   */\n  _rate = 1;\n\n  /**\n   * True if the sound is currently muted.\n   * @type {boolean}\n   * @private\n   */\n  _muted = false;\n\n  /**\n   * True if the sound should play repeatedly.\n   * @type {boolean}\n   * @private\n   */\n  _loop = false;\n\n  /**\n   * The current state (playing, paused etc.) of the sound.\n   * @type {SoundState}\n   * @private\n   */\n  _state = SoundState.Ready;\n\n  /**\n   * Web API's audio context.\n   * @type {AudioContext}\n   * @private\n   */\n  _context = null;\n\n  /**\n   * The gain node to control the volume of the sound.\n   * @type {GainNode}\n   * @private\n   */\n  _gainNode = null;\n\n  /**\n   * True to use HTML5 audio node.\n   * @type {boolean}\n   * @private\n   */\n  _stream = false;\n\n  /**\n   * The audio buffer.\n   * @type {AudioBuffer}\n   * @private\n   */\n  _buffer = null;\n\n  /**\n   * The HTML5 Audio element.\n   * @type {Audio}\n   * @private\n   */\n  _audio = null;\n\n  /**\n   * The AudioBufferSourceNode that plays the audio buffer assigned to it.\n   * @type {AudioBufferSourceNode}\n   * @private\n   */\n  _bufferSourceNode = null;\n\n  /**\n   * Duration of the playback in seconds.\n   * @type {number}\n   * @private\n   */\n  _duration = 0;\n\n  /**\n   * The playback start position.\n   * @type {number}\n   * @private\n   */\n  _startPos = 0;\n\n  /**\n   * The playback end position.\n   * @type {number}\n   * @private\n   */\n  _endPos = 0;\n\n  /**\n   * The current position of the playback.\n   * @type {number}\n   * @private\n   */\n  _currentPos = 0;\n\n  /**\n   * The position of the playback during rate change.\n   * @type {number}\n   * @private\n   */\n  _rateSeek = 0;\n\n  /**\n   * The time at which the playback started.\n   * This property is required for getting the seek position of the playback.\n   * @type {number}\n   * @private\n   */\n  _startTime = 0;\n\n  /**\n   * The callback that will be called when the underlying HTML5 audio node is loaded.\n   * @type {function}\n   * @private\n   */\n  _loadCallback = null;\n\n  /**\n   * The callback that will be invoked after the play ends.\n   * @type {function}\n   * @private\n   */\n  _playEndCallback = null;\n\n  /**\n   * The callback that will be invoked after the sound destroyed.\n   * @type {function}\n   * @private\n   */\n  _destroyCallback = null;\n\n  /**\n   * True if the sound is currently fading.\n   * @type {boolean}\n   * @private\n   */\n  _fading = false;\n\n  /**\n   * The timer that runs function after the fading is complete.\n   * @type {number|null}\n   * @private\n   */\n  _fadeTimer = null;\n\n  /**\n   * The callback that will be invoked after the fade is completed.\n   * @type {function}\n   * @private\n   */\n  _fadeEndCallback = null;\n\n  /**\n   * The callback that will be invoked when there is error in HTML5 audio node.\n   * @type {function}\n   * @private\n   */\n  _audioErrorCallback = null;\n\n  /**\n   * Web Audio API's audio node to control media element.\n   * @type {MediaElementAudioSourceNode}\n   * @private\n   */\n  _mediaElementAudioSourceNode = null;\n\n  /**\n   * Represents the timer that is used to reset the variables once the sprite sound is played.\n   * @type {number|null}\n   * @private\n   */\n  _endTimer = null;\n\n  /**\n   * True for sprite.\n   * @type {boolean}\n   * @private\n   */\n  _isSprite = false;\n\n  /**\n   * Last played time.\n   * @type {Date}\n   * @private\n   */\n  _lastPlayed = new Date();\n\n  /**\n   * True to not auto-destroy.\n   * @type {boolean}\n   * @private\n   */\n  _persist = false;\n\n  /**\n   * Initializes the internal properties of the sound.\n   * @param {object} args The input parameters of the sound.\n   * @param {string} args.id The unique id of the sound.\n   * @param {boolean} [args.stream = false] True to use HTML5 audio node for playing sound.\n   * @param {Audio} [args.audio] The pre-loaded HTML5 audio object.\n   * @param {AudioBuffer} [args.buffer] Audio source buffer.\n   * @param {number} [args.volume = 1.0] The initial volume of the sound. Should be from 0.0 to 1.0.\n   * @param {number} [args.rate = 1] The initial playback rate of the sound. Should be from 0.5 to 5.0.\n   * @param {boolean} [args.loop = false] True to play the sound repeatedly.\n   * @param {boolean} [args.muted = false] True to be muted initially.\n   * @param {number} [args.startPos] The playback start position.\n   * @param {number} [args.endPos] The playback end position.\n   * @param {function} [args.loadCallback] The callback that will be called when the underlying HTML5 audio node is loaded.\n   * @param {function} [args.playEndCallback] The callback that will be invoked after the play ends.\n   * @param {function} [args.destroyCallback] The callback that will be invoked after destroyed.\n   * @param {function} [args.fadeEndCallback] The callback that will be invoked the fade is completed.\n   * @param {function} [args.audioErrorCallback] The callback that will be invoked when there is error in HTML5 audio node.\n   * @constructor\n   */\n  constructor(args) {\n    const {\n      id,\n      stream,\n      buffer,\n      audio,\n      volume,\n      rate,\n      loop,\n      muted,\n      startPos,\n      endPos,\n      loadCallback,\n      playEndCallback,\n      destroyCallback,\n      fadeEndCallback,\n      audioErrorCallback\n    } = args;\n\n    // Set the passed id or the random one.\n    this._id = typeof id === 'number' ? id : utility.id();\n\n    // Set the passed audio buffer and duration.\n    this._buffer = buffer;\n    this._audio = audio;\n\n    // Set other properties.\n    volume && (this._volume = volume);\n    rate && (this._rate = rate);\n    muted && (this._muted = muted);\n    loop && (this._loop = loop);\n    startPos && (this._startPos = startPos);\n    endPos && (this._endPos = endPos);\n    this._loadCallback = loadCallback;\n    this._playEndCallback = playEndCallback;\n    this._destroyCallback = destroyCallback;\n    this._fadeEndCallback = fadeEndCallback;\n    this._audioErrorCallback = audioErrorCallback;\n    this._stream = Boolean(stream);\n\n    this._endPos = this._stream ? this._audio.duration : this._buffer.duration;\n    this._duration = this._endPos - this._startPos;\n    this._isSprite = this._duration < this._endPos;\n\n    // If stream is `true` then set the playback rate, looping and listen to `error` event.\n    if (this._stream) {\n      this._audio.playbackRate = this._rate;\n      this._setLoop(this._loop);\n      this._audio.addEventListener('error', this._onAudioError);\n    }\n\n    // If web audio is available, create gain node and set the volume..\n    if (engine.isAudioAvailable()) {\n      this._context = engine.context();\n      this._gainNode = this._context.createGain();\n      this._gainNode.gain.setValueAtTime(this._muted ? 0 : this._volume, this._context.currentTime);\n\n      // Create media element audio source node.\n      if (this._stream) {\n        this._mediaElementAudioSourceNode = this._context.createMediaElementSource(this._audio);\n        this._mediaElementAudioSourceNode.connect(this._gainNode);\n      }\n    }\n\n    this._onBufferEnded = this._onBufferEnded.bind(this);\n    this._onHtml5Ended = this._onHtml5Ended.bind(this);\n  }\n\n  /**\n   * Pre-loads the underlying HTML audio node (only in case of stream).\n   */\n  load() {\n    if (!this._stream || this.isPlaying() || this.state() === SoundState.Destroyed) {\n      return;\n    }\n\n    const onCanPlayThrough = () => {\n      this._loadCallback();\n      this._audio.removeEventListener('canplaythrough', onCanPlayThrough);\n    };\n\n    this._audio.addEventListener('canplaythrough', onCanPlayThrough);\n    this._audio.currentTime = 0;\n\n    if (this._audio.readyState >= 3) {\n      onCanPlayThrough();\n    }\n  }\n\n  /**\n   * Plays the sound or the sound defined in the sprite.\n   * @return {Sound}\n   */\n  play() {\n    // If the sound is already playing then return.\n    if (this.isPlaying()) {\n      return this;\n    }\n\n    this._stream ? this._playHtml5() : this._playBuffer();\n\n    // Record the starting time and set the state.\n    this._startTime = this._context.currentTime;\n    this._state = SoundState.Playing;\n\n    return this;\n  }\n\n  /**\n   * Pauses the playing sound.\n   * @return {Sound}\n   */\n  pause() {\n    // If the sound is already playing return.\n    if (!this.isPlaying()) {\n      return this;\n    }\n\n    // Stop the current running fade.\n    this.fadeStop();\n\n    if (this._stream) {\n      this._audio.removeEventListener('ended', this._onHtml5Ended);\n      this._clearEndTimer();\n      this._audio.pause();\n    } else {\n      this._rateSeek = 0;\n      this._destroyBufferNode();\n    }\n\n    this._currentPos = this.seek();\n    this._state = SoundState.Paused;\n\n    return this;\n  }\n\n  /**\n   * Stops the sound that is playing or in paused state.\n   * @return {Sound}\n   */\n  stop() {\n    // If the sound is not playing or paused return.\n    if (!this.isPlaying() && !this.isPaused()) {\n      return this;\n    }\n\n    // Stop the current running fade.\n    this.fadeStop();\n\n    if (this._stream) {\n      this._audio.removeEventListener('ended', this._onEnded);\n      this._clearEndTimer();\n      this._audio.pause();\n      this._audio.currentTime = this._startPos || 0;\n    } else {\n      this._currentPos = 0;\n      this._rateSeek = 0;\n      this._destroyBufferNode();\n    }\n\n    this._lastPlayed = new Date();\n\n    this._state = SoundState.Ready;\n\n    return this;\n  }\n\n  /**\n   * Mutes the sound.\n   * @return {Sound}\n   */\n  mute() {\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Set the value of gain node to 0.\n    this._gainNode.gain.setValueAtTime(0, this._context.currentTime);\n\n    // Set the muted property true.\n    this._muted = true;\n\n    return this;\n  }\n\n  /**\n   * Un-mutes the sound.\n   * @return {Sound}\n   */\n  unmute() {\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Reset the gain node's value back to volume.\n    this._gainNode.gain.setValueAtTime(this._volume, this._context.currentTime);\n\n    // Set the muted property to false.\n    this._muted = false;\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the volume.\n   * @param {number} [vol] Should be from 0.0 to 1.0.\n   * @return {Sound|number}\n   */\n  volume(vol) {\n    // If no input parameter is passed then return the volume.\n    if (typeof vol === 'undefined') {\n      return this._volume;\n    }\n\n    // Stop the current running fade.\n    this.fadeStop();\n\n    // Set the gain's value to the passed volume.\n    this._gainNode.gain.setValueAtTime(this._muted ? 0 : vol, this._context.currentTime);\n\n    // Set the volume to the property.\n    this._volume = vol;\n\n    return this;\n  }\n\n  /**\n   * Fades the sound volume to the passed value in the passed duration.\n   * @param {number} to The destination volume.\n   * @param {number} duration The period of fade.\n   * @param {string} [type = linear] The fade type (linear or exponential).\n   * @return {Sound}\n   */\n  fade(to, duration, type = 'linear') {\n    // If a fade is already running stop it.\n    if (this._fading) {\n      this.fadeStop();\n    }\n\n    this._fading = true;\n\n    if (type === 'linear') {\n      this._gainNode.gain.linearRampToValueAtTime(to, this._context.currentTime + duration);\n    } else {\n      this._gainNode.gain.exponentialRampToValueAtTime(to, this._context.currentTime + duration);\n    }\n\n    this._fadeTimer = workerTimer.setTimeout(() => {\n      this.volume(to);\n\n      workerTimer.clearTimeout(this._fadeTimer);\n\n      this._fadeTimer = null;\n      this._fading = false;\n\n      this._fadeEndCallback && this._fadeEndCallback(this);\n    }, duration * 1000);\n\n    return this;\n  }\n\n  /**\n   * Stops the current running fade.\n   * @return {Sound}\n   */\n  fadeStop() {\n    if (!this._fading) {\n      return this;\n    }\n\n    this._gainNode.gain.cancelScheduledValues(this._context.currentTime);\n\n    if (this._fadeTimer) {\n      workerTimer.clearTimeout(this._fadeTimer);\n      this._fadeTimer = null;\n    }\n\n    this._fading = false;\n    this.volume(this._gainNode.gain.value);\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the playback rate.\n   * @param {number} [rate] The playback rate. Should be from 0.5 to 5.\n   * @return {Sound|number}\n   */\n  rate(rate) {\n    // If no input parameter is passed return the current rate.\n    if (typeof rate === 'undefined') {\n      return this._rate;\n    }\n\n    this._rate = rate;\n    this._rateSeek = this.seek();\n\n    if (this.isPlaying()) {\n      if (this._stream) {\n        this._audio.playbackRate = rate;\n\n        if (this._isSprite) {\n          this._clearEndTimer();\n          let [, duration] = this._getTimeVars();\n          this._endTimer = workerTimer.setTimeout(this._onEnded, (duration * 1000) / Math.abs(rate));\n        }\n      } else {\n        this._startTime = this._context.currentTime;\n        this._bufferSourceNode && (this._bufferSourceNode.playbackRate.setValueAtTime(rate, this._context.currentTime));\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the seek position.\n   * @param {number} [seek] The seek position.\n   * @return {Sound|number}\n   */\n  seek(seek) {\n    // If no parameter is passed return the current position.\n    if (typeof seek === 'undefined') {\n      if (this._stream) {\n        return this._audio.currentTime;\n      }\n\n      const realTime = this.isPlaying() ? this._context.currentTime - this._startTime : 0;\n      const rateElapsed = this._rateSeek ? this._rateSeek - this._currentPos : 0;\n      return this._currentPos + (rateElapsed + realTime * this._rate);\n    }\n\n    // If seeking outside the borders then return.\n    if (seek < this._startPos || seek > this._endPos) {\n      return this;\n    }\n\n    // If the sound is currently playing... pause it, set the seek position and then continue playing.\n    const isPlaying = this.isPlaying();\n\n    if (isPlaying) {\n      this.pause();\n    }\n\n    this._currentPos = seek;\n\n    if (isPlaying) {\n      this.play();\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets/sets the loop parameter of the sound.\n   * @param {boolean} [loop] True to loop the sound.\n   * @return {Sound/boolean}\n   */\n  loop(loop) {\n    if (typeof loop !== 'boolean') {\n      return this._loop;\n    }\n\n    this._loop = loop;\n    this._setLoop(loop);\n\n    return this;\n  }\n\n  /**\n   * Destroys the dependencies and release the memory.\n   * @return {Sound}\n   */\n  destroy() {\n    // If the sound is already destroyed return.\n    if (this._state === SoundState.Destroyed) {\n      return this;\n    }\n\n    // Stop the sound.\n    this.stop();\n\n    this._destroyMediaSourceNode();\n    this._audio && this._audio.removeEventListener('error', this._onAudioError);\n\n    this._gainNode && this._gainNode.disconnect();\n\n    this._buffer = null;\n    this._audio = null;\n    this._context = null;\n    this._gainNode = null;\n\n    // Set the state to \"destroyed\".\n    this._state = SoundState.Destroyed;\n\n    this._destroyCallback && this._destroyCallback(this);\n\n    return this;\n  }\n\n  /**\n   * Returns the unique id of the sound.\n   * @return {number}\n   */\n  id() {\n    return this._id;\n  }\n\n  /**\n   * Returns whether the sound is muted or not.\n   * @return {boolean}\n   */\n  muted() {\n    return this._muted;\n  }\n\n  /**\n   * Returns the state of the sound.\n   * @return {SoundState}\n   */\n  state() {\n    return this._state;\n  }\n\n  /**\n   * Returns the total duration of the playback.\n   * @return {number}\n   */\n  duration() {\n    return this._duration;\n  }\n\n  /**\n   * Returns true if the buzz is playing.\n   * @return {boolean}\n   */\n  isPlaying() {\n    return this._state === SoundState.Playing;\n  }\n\n  /**\n   * Returns true if buzz is paused.\n   * @return {boolean}\n   */\n  isPaused() {\n    return this._state === SoundState.Paused;\n  }\n\n  /**\n   * Returns last played time.\n   * @return {number}\n   */\n  lastPlayed() {\n    return this._lastPlayed;\n  }\n\n  /**\n   * Disables auto-destroy.\n   */\n  persist() {\n    if (this._state === SoundState.Destroyed) {\n      return;\n    }\n\n    this._persist = true;\n  }\n\n  /**\n   * Enables auto-destroy.\n   */\n  abandon() {\n    if (this._state === SoundState.Destroyed) {\n      return;\n    }\n\n    this._persist = false;\n  }\n\n  /**\n   * Returns true if auto-destroy enabled.\n   * @return {boolean}\n   */\n  isPersistent() {\n    return this._persist;\n  }\n\n  /**\n   * HTML5 Audio error handler.\n   * @param {object} err Error object.\n   * @private\n   */\n  _onAudioError(err) {\n    this._audioErrorCallback && this._audioErrorCallback(this, err);\n  }\n\n  /**\n   * Returns the seek, duration and timeout for the playback.\n   * @return {[number, number, number]}\n   * @private\n   */\n  _getTimeVars() {\n    let seek = Math.max(0, this._currentPos > 0 ? this._currentPos : this._startPos),\n      duration = this._endPos - this._startPos,\n      timeout = (duration * 1000) / this._rate;\n\n    return [seek, duration, timeout];\n  }\n\n  /**\n   * Plays the audio using audio buffer.\n   * @private\n   */\n  _playBuffer() {\n    let [seek, duration] = this._getTimeVars();\n\n    // Create a new buffersourcenode to play the sound.\n    this._bufferSourceNode = this._context.createBufferSource();\n\n    // Set the buffer, playback rate and loop parameters\n    this._bufferSourceNode.buffer = this._buffer;\n    this._bufferSourceNode.playbackRate.setValueAtTime(this._rate, this._context.currentTime);\n    this._setLoop(this._loop);\n\n    // Connect the node to the audio graph.\n    this._bufferSourceNode.connect(this._gainNode);\n\n    // Listen to the \"ended\" event to reset/clean things.\n    this._bufferSourceNode.addEventListener('ended', this._onBufferEnded);\n\n    const startTime = this._context.currentTime;\n\n    // Call the supported method to play the sound.\n    if (typeof this._bufferSourceNode.start !== 'undefined') {\n      this._bufferSourceNode.start(startTime, seek, this._loop ? undefined : duration);\n    } else {\n      this._bufferSourceNode.noteGrainOn(startTime, seek, this._loop ? undefined : duration);\n    }\n  }\n\n  /**\n   * Plays the audio using HTML5 audio object.\n   * @private\n   */\n  _playHtml5() {\n    let [seek, , timeout] = this._getTimeVars();\n\n    this._audio.currentTime = seek;\n\n    if (this._isSprite) {\n      this._endTimer = workerTimer.setTimeout(this._onHtml5Ended, timeout);\n    } else {\n      this._audio.addEventListener('ended', this._onHtml5Ended);\n    }\n\n    this._audio.play();\n  }\n\n  /**\n   * Callback that is invoked after the buffer playback is ended.\n   * @private\n   */\n  _onBufferEnded() {\n    this._lastPlayed = new Date();\n\n    // Reset the seek positions\n    this._currentPos = 0;\n    this._rateSeek = 0;\n\n    // Destroy the node (AudioBufferSourceNodes are one-time use and throw objects).\n    this._destroyBufferNode();\n\n    // Reset the state to allow future actions.\n    this._state = SoundState.Ready;\n\n    // Invoke the callback if there is one.\n    this._playEndCallback && this._playEndCallback(this);\n  }\n\n  /**\n   * Callback that is invoked after the html audio playback is ended.\n   * @private\n   */\n  _onHtml5Ended() {\n    if (this._loop) {\n      this.stop().play();\n    } else {\n      this.stop();\n      this._state = SoundState.Ready;\n      this._playEndCallback && this._playEndCallback(this);\n    }\n  }\n\n  /**\n   * Clears the end-timer.\n   * @private\n   */\n  _clearEndTimer() {\n    if (!this._endTimer) {\n      return;\n    }\n\n    workerTimer.clearTimeout(this._endTimer);\n    this._endTimer = null;\n  }\n\n  /**\n   * Returns the gain node.\n   * @return {GainNode}\n   */\n  _gain() {\n    return this._gainNode;\n  }\n\n  /**\n   * Stops the playing buffer source node and destroys it.\n   * @private\n   */\n  _destroyBufferNode() {\n    if (!this._bufferSourceNode) {\n      return;\n    }\n\n    if (typeof this._bufferSourceNode.stop !== 'undefined') {\n      this._bufferSourceNode.stop();\n    } else {\n      this._bufferSourceNode.noteGrainOff();\n    }\n\n    this._bufferSourceNode.disconnect();\n    this._bufferSourceNode.removeEventListener('ended', this._onBufferEnded);\n    this._bufferSourceNode = null;\n  }\n\n  /**\n   * Destroys the media audio source node.\n   * @private\n   */\n  _destroyMediaSourceNode() {\n    if (!this._mediaElementAudioSourceNode) {\n      return;\n    }\n\n    this._mediaElementAudioSourceNode.disconnect();\n    this._mediaElementAudioSourceNode = null;\n  }\n\n  /**\n   * Sets the sound to play repeatedly or not.\n   * @param {boolean} loop True to play the sound repeatedly.\n   * @private\n   */\n  _setLoop(loop) {\n    if (this._stream) {\n      this._audio.loop = loop;\n    } else {\n      this._bufferSourceNode.loop = loop;\n\n      if (loop) {\n        this._bufferSourceNode.loopStart = this._startPos;\n        this._bufferSourceNode.loopEnd = this._endPos;\n      }\n    }\n  }\n}\n\nexport { Sound as default, SoundState };\n","// Credit: https://github.com/goldfire/howler.js/issues/626\n\nconst WORKER_SCRIPT = `\n  var timerIds = {}, timeoutWorker = {};\n  \n  timeoutWorker.setTimeout = function(timerId, duration) {\n    timerIds[timerId] = setTimeout(function() {\n      postMessage({ timerId: timerId });\n    }, duration);\n  };\n  \n  timeoutWorker.clearTimeout = function(timerId) {\n    clearTimeout(timerIds[timerId]);\n  };\n  \n  timeoutWorker.setInterval = function(timerId, duration) {\n    timerIds[timerId] = setInterval(function() {\n      postMessage({ timerId: timerId });\n    }, duration);\n  };\n  \n  timeoutWorker.clearInterval = function(timerId) {\n    clearInterval(timerIds[timerId]);\n  };\n  \n  onmessage = function(e) {\n    var command = e.data.command;\n    timeoutWorker[command](e.data.timerId, e.data.duration);\n  };\n`;\n\n/**\n * Provides more accurate timeouts and intervals when the browser tab is not active using Web Workers.\n * @class\n */\nclass WorkerTimer {\n\n  /**\n   * Web worker.\n   * @type {Worker}\n   * @private\n   */\n  _worker = null;\n\n  /**\n   * Whether Web Worker is available or not. If not available then normal setTimeout and setInterval will be used.\n   * @type {boolean}\n   * @private\n   */\n  _isWorkerThreadAvailable = false;\n\n  /**\n   * Dictionary to store the callbacks that should be invoked after timeouts and intervals.\n   * @type {{}}\n   * @private\n   */\n  _timerCallbacks = {};\n\n  /**\n   * The incrementing id that is used to link the timer running in worker with the callback.\n   * @type {number}\n   * @private\n   */\n  _timerId = 0;\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    this._handleMessage = this._handleMessage.bind(this);\n  }\n\n  /**\n   * Initialize the worker\n   */\n  init() {\n    if (!Worker || this._worker) {\n      return;\n    }\n\n    let blob = this._getBlob(WORKER_SCRIPT);\n    if (blob === null) {\n      return;\n    }\n\n    let workerUrl = this._createObjectURL(blob);\n    if (workerUrl === null) {\n      return;\n    }\n\n    this._worker = new Worker(workerUrl);\n    this._worker.addEventListener('message', this._handleMessage);\n    this._isWorkerThreadAvailable = true;\n  }\n\n  /**\n   * Returns a blob.\n   * @param {string} script The javascript code string.\n   * @return {*}\n   * @private\n   */\n  _getBlob(script) {\n    let blob = null;\n\n    try {\n      blob = new Blob([script], { type: 'application/javascript' });\n    } catch (e) {\n      let blobBuilderType = null;\n\n      if (typeof BlobBuilder !== 'undefined') {\n        blobBuilderType = BlobBuilder;\n      } else if (typeof WebKitBlobBuilder !== 'undefined') {\n        blobBuilderType = WebKitBlobBuilder;\n      }\n\n      blob = new blobBuilderType(); // eslint-disable-line new-cap\n      blob.append(script);\n      blob = blob.getBlob();\n    }\n\n    return blob;\n  }\n\n  /**\n   * Returns object url.\n   * @param {*} file The blob.\n   * @return {*}\n   * @private\n   */\n  _createObjectURL(file) {\n    if (typeof URL !== 'undefined' && URL.createObjectURL) {\n      return URL.createObjectURL(file);\n    } else if (typeof webkitURL !== 'undefined') {\n      return webkitURL.createObjectURL(file);\n    }\n\n    return null;\n  }\n\n  /**\n   * Callback that handles the messages send by worker.\n   * @param {object} e Event argument that contains the message data and other information\n   * @private\n   */\n  _handleMessage(e) {\n    const callback = this._timerCallbacks[e.data.timerId];\n\n    if (callback && callback.cb) {\n      callback.cb();\n    }\n\n    if (!callback.repeat) {\n      delete this._timerCallbacks[e.data.timerId];\n    }\n  }\n\n  /**\n   * Invokes a callback after the passed time.\n   * @param {function} callback The callback that should be called after the elapsed period.\n   * @param {number} duration The time period in ms.\n   * @return {number}\n   */\n  setTimeout(callback, duration) {\n    if (!this._isWorkerThreadAvailable) {\n      return setTimeout(callback, duration);\n    }\n\n    this._timerId = this._timerId + 1;\n    this._timerCallbacks[this._timerId] = { cb: callback, repeat: false };\n    this._worker.postMessage({ command: 'setTimeout', timerId: this._timerId, duration: duration });\n    return this._timerId;\n  }\n\n  /**\n   * Clears the scheduled timeout.\n   * @param {number} timeoutId The timeout id.\n   */\n  clearTimeout(timeoutId) {\n    if (!this._isWorkerThreadAvailable) {\n      return clearTimeout(timeoutId);\n    }\n\n    this._worker.postMessage({ command: 'clearTimeout', timerId: timeoutId });\n    delete this._timerCallbacks[timeoutId];\n  }\n\n  /**\n   * Invokes the callback function at the passed interval.\n   * @param {function} callback The callback function.\n   * @param {number} duration The time interval.\n   * @return {number}\n   */\n  setInterval(callback, duration) {\n    if (!this._isWorkerThreadAvailable) {\n      return setInterval(callback, duration);\n    }\n\n    this._timerId = this._timerId + 1;\n    this._timerCallbacks[this._timerId] = { cb: callback, repeat: true };\n    this._worker.postMessage({ command: 'setInterval', timerId: this._timerId, duration: duration });\n    return this._timerId;\n  }\n\n  /**\n   * Clears the scheduled interval.\n   * @param {number} intervalId The interval id.\n   */\n  clearInterval(intervalId) {\n    if (!this._isWorkerThreadAvailable) {\n      return clearTimeout(intervalId);\n    }\n\n    this._worker.postMessage({ command: 'clearTimeout', timerId: intervalId });\n    delete this._timerCallbacks[intervalId];\n  }\n\n  /**\n   * Kills the worker thread.\n   */\n  terminate() {\n    if (this._worker) {\n      this._worker.removeEventListener('message', this._handleMessage);\n      this._worker.terminate();\n      this._worker = null;\n    }\n\n    this._isWorkerThreadAvailable = false;\n    this._timerCallbacks = {};\n    this._timerId = 0;\n  }\n}\n\nexport default new WorkerTimer();\n"],"sourceRoot":""}